<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="kernel,bus," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="Linux I2C FrameworkLinux kernel: 3.10.67
I2C Protocol: UM10204 I2C-bus specification and user manual 
I2C Bus ProtocolI2C（Inter-Integrated Circuit）是 Philips 推出的适用于近距离低速芯片间通信的主从式的串行总线标准，支持多个主节点和多个从节点
I">
<meta property="og:type" content="article">
<meta property="og:title" content="I2C Framework">
<meta property="og:url" content="http://yoursite.com/2017/05/26/i2c-framework/index.html">
<meta property="og:site_name" content="LostJeffle">
<meta property="og:description" content="Linux I2C FrameworkLinux kernel: 3.10.67
I2C Protocol: UM10204 I2C-bus specification and user manual 
I2C Bus ProtocolI2C（Inter-Integrated Circuit）是 Philips 推出的适用于近距离低速芯片间通信的主从式的串行总线标准，支持多个主节点和多个从节点
I">
<meta property="og:image" content="http://yoursite.com/images/i2c/14824572061475.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14824573157596.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14824574567477.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14824578840876.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14824594242559.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/I2C_data_transfer.png">
<meta property="og:image" content="http://yoursite.com/images/i2c/I2C_10bit.png">
<meta property="og:image" content="http://yoursite.com/images/i2c/i2c_hw_topology.png">
<meta property="og:image" content="http://yoursite.com/images/i2c/14824596543903.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14824596955160.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14824597244531.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14867036827105.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14867038239038.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14867037352403.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14867041597629.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14867040117290.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14867041338477.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14867039275306.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14867042412870.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14867042641537.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14867063624610.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14867068559951.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/14867070346714.jpg">
<meta property="og:image" content="http://yoursite.com/images/i2c/i2c_sw_topology.png">
<meta property="og:updated_time" content="2017-05-26T05:01:39.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="I2C Framework">
<meta name="twitter:description" content="Linux I2C FrameworkLinux kernel: 3.10.67
I2C Protocol: UM10204 I2C-bus specification and user manual 
I2C Bus ProtocolI2C（Inter-Integrated Circuit）是 Philips 推出的适用于近距离低速芯片间通信的主从式的串行总线标准，支持多个主节点和多个从节点
I">
<meta name="twitter:image" content="http://yoursite.com/images/i2c/14824572061475.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> I2C Framework | LostJeffle </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">LostJeffle</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'kd8Li3UqssgpyxA9GSfy','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                I2C Framework
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-26T12:42:16+08:00" content="2017-05-26">
              2017-05-26
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Linux-I2C-Framework"><a href="#Linux-I2C-Framework" class="headerlink" title="Linux I2C Framework"></a>Linux I2C Framework</h1><p>Linux kernel: 3.10.67</p>
<p>I2C Protocol: UM10204 I2C-bus specification and user manual </p>
<h2 id="I2C-Bus-Protocol"><a href="#I2C-Bus-Protocol" class="headerlink" title="I2C Bus Protocol"></a>I2C Bus Protocol</h2><p>I2C（Inter-Integrated Circuit）是 Philips 推出的适用于近距离低速芯片间通信的主从式的串行总线标准，支持多个主节点和多个从节点</p>
<p>I2C 总线是主从式总线，主设备（master）负责产生时钟信号、决定一次数据传输的开始与结束，而其它被主设备寻址的均为从设备（slave）</p>
<a id="more"></a>
<h3 id="Bus-Specification"><a href="#Bus-Specification" class="headerlink" title="Bus Specification"></a>Bus Specification</h3><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p><img src="/images/i2c/14824572061475.jpg" alt="I2C-c600"></p>
<p>总线由双向串行数据信号 SDA 和双向串行时钟信号 SCL 构成，主节点和从节点分别并联至总线。</p>
<h4 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h4><p><img src="/images/i2c/14824573157596.jpg" alt="I2C_bit_transfer-c400"><br>数据传输时，SCL 高电平期间 SDA 须保持稳定，SCL 低电平期间 SDA 可以改变数据。</p>
<p><img src="/images/i2c/14824574567477.jpg" alt="I2C_start_stop-c500"><br>数据传输在开始信号S和结束信号P之间进行，SCL高电平期间SDA由高电平变为低电平表示开始信号S，SDA由低电平变为高电平表示结束信号P；master device发送开始信号后认为总线处于busy状态，直至master device发送结束信号并等待一段时间后认为总线恢复free状态</p>
<p><img src="/images/i2c/14824578840876.jpg" alt="I2c_byte_transfer-c"></p>
<p>一个字节的数据传输需要9个时钟周期，其中前8位为传输的一字节的数据，第9位为receiver的应答信号。传输完一个字节的数据后，第9个时钟低电平期间，transmitter释放 SDA，receiver将 SDA 拉低，以发送应答信号；第9个时钟高电平期间，transmitter收到应答信号，发起下一个字节数据的传输或发送结束信号。</p>
<p>当从设备需要响应中断事件而不能及时接收或发送I2C数据时，可以拉低SCL，并迫使主设备进入等待状态，直到从设备拉高SCL，I2C总线重新恢复为正常的数据传输状态</p>
<p><img src="/images/i2c/14824594242559.jpg" alt="-c600"></p>
<p>开始信号后的第一个字节用来传输从节点的地址，前7位为地址码，第8位为读写位（R/W）。</p>
<table>
<thead>
<tr>
<th>START</th>
<th>Slave Address</th>
<th>R/nW</th>
<th>ACK</th>
<th>Data</th>
<th>ACK</th>
<th>Data</th>
<th>ACK</th>
<th>STOP</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 bit</td>
<td>7 bit</td>
<td>1 bit</td>
<td>1 bit</td>
<td>8 bit</td>
<td>1 bit</td>
<td>8 bit</td>
<td>1 bit</td>
<td>1 bit</td>
</tr>
</tbody>
</table>
<p><img src="/images/i2c/I2C_data_transfer.png" alt="I2C_data_transfe-c"></p>
<ol>
<li>SCL 高电平时，SDA 由高电平向低电平跳变，数据传输开始（S）</li>
<li>SCL 低电平时，SDA 设置为第一位数据的电平</li>
<li>SCL 高电平时，对 SDA 进行采样获得第一位数据（B1）</li>
<li>重复过程2、3</li>
<li>SCL 高电平时，SDA 由低电平向高电平跳变，数据传输结束（P）</li>
</ol>
<p>一次数据传输在开始信号S和结束信号P之间进行，其间可以进行多个字节的数据传输，字节的数量不受限制；一个字节的数据传输需要9个时钟周期，其中前8位为传输的一字节的数据，第9位为从节点的应答信号ACK或NACK， 字节数据的传输遵从Most Significant Bit (MSB) first原则；同时当进行连续的多次数据传输时，其间的结束信号P可以省略，而是直接发送开始信号S以开始新的一次数据传输</p>
<p>在第9个时钟低电平期间，transmitter释放 SDA，receiver将 SDA 拉低，并在第9个时钟高电平期间使其保持低电平状态，以发送应答信号ACK，该信号用于通知transmitter其已经成功接收之前传输的一个字节的数据，并且transmitter可以准备发送下一字节的数据</p>
<p>当第9个时钟高电平期间SDA保持为高电平时，receiver向transmitter发送NACK信号，此时主设备可以发送结束信号P以结束此次传输，或发送开始信号S以开始新的一次数据传输</p>
<p>10-bit addressing可以扩展I2C的地址空间，当使用10-bit地址时，数据传输的开始两个字节用于表示slave device的地址，其中第一个字节的前7位数据为1111 0XX，其后两个bit表示10-bit address的高2位 Most-Significant Bits (MSB)，第一个字节的最后一个bit为R/nW，第二个字节表示10-bit address的低8位</p>
<p><img src="/images/i2c/I2C_10bit.png" alt="I2C_10bit-c600"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D6 D5 D4 D3 D2 D1 D0</span><br></pre></td></tr></table></figure>
<p>I2C slave device的7-bit address，其中高4位由设备的生产厂商决定，与设备型号相关；其低3位固定或由外部IC引脚的电平决定</p>
<h4 id="硬件拓扑"><a href="#硬件拓扑" class="headerlink" title="硬件拓扑"></a>硬件拓扑</h4><p><img src="/images/i2c/i2c_hw_topology.png" alt="i2c_hw_topology-c550"></p>
<p>I2C 是主从式总线，Linux 默认运行有 Linux 内核的设备为 I2C 主设备，其它的为从设备</p>
<p>CPU 与 slave device 的连接方式有</p>
<ul>
<li><p>slave device 与 i2c controller 直接通过 i2c bus 相连，CPU 与设备间的数据交互与配置事务均通过i2c总线进行</p>
</li>
<li><p>slave device 与 i2c controller 通过 i2c bus 相连，同时slave device还通过其他总线与CPU上的其他controller相连，例如ov13850通过i2c bus与i2c controller相连，同时通过MIPI（CSI）接口与CPU连接。CPU通过i2c总线对设备的传感器进行配置，同时通过MIPI（CSI）接口与设备实现数据交互，获取传感器的输出数据</p>
</li>
</ul>
<h5 id="形态1"><a href="#形态1" class="headerlink" title="形态1"></a>形态1</h5><p>对于形态1，内核将该设备视为i2c controller下挂载的一个slave device，在设备树中通常在i2c controller的节点下描述该设备的节点信息</p>
<p>在i2c controller的platform driver的probe函数中为该i2c controller下的slave device分配i2c_client，并将该i2c_client注册到i2c_bus_type，当该slave device的i2c_driver注册到i2c_bus_type并匹配成功时，执行该i2c_driver的probe函数</p>
<h5 id="形态2"><a href="#形态2" class="headerlink" title="形态2"></a>形态2</h5><p>对于形态2，内核将该设备视为一个platform device，在设备树中该设备的节点通常位于根节点之下，并且在该节点中使用一个变量，指向其I2C adapter的DTS节点，例如：”ddc-i2c-bus = &lt;&amp;i2c2&gt;;”</p>
<p>在该设备的platform driver中以”ddc-i2c-bus”参数，调用of_parse_phandle()接口，获取I2C adapter的device node（即i2c的device node），然后调用of_find_i2c_adapter_by_node()获取相应的I2C adapter指针</p>
<h3 id="Data-Transfer"><a href="#Data-Transfer" class="headerlink" title="Data Transfer"></a>Data Transfer</h3><table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>S       (1 bit)</td>
<td>开始位</td>
</tr>
<tr>
<td>P       (1 bit)</td>
<td>停止位</td>
</tr>
<tr>
<td>Rd/Wr   (1 bit)</td>
<td>读写标志位，Rd为1，Wr为0</td>
</tr>
<tr>
<td>A/NA    (1 bit)</td>
<td>Accept / Reverse Accept</td>
</tr>
<tr>
<td>Addr    (7 bit)</td>
<td>slave device 的地址</td>
</tr>
<tr>
<td>Comm    (8 bit)</td>
<td>Command byte，通常包含需要读写的寄存器的地址</td>
</tr>
<tr>
<td>Data    (8 bit)</td>
<td>Data byte</td>
</tr>
<tr>
<td>Count   (8 bit)</td>
<td>当执行块数据读写时，该字节表明数据的长度</td>
</tr>
<tr>
<td>[..]</td>
<td>slave device 发送的数据包</td>
</tr>
</tbody>
</table>
<p>对于standard I2C protocol，slave device允许不响应其i2c address，而SMBus protocol规定slave device必须响应其i2c address，通过该特性SMBus protocol可以自动探测当前插入的热插拔设备</p>
<p>同时对于standard I2C protocol，NA 表示receiver不能继续接收数据，从而结束该次数据传输；而对于SMBus protocol，NA 表示slave device接收到invalid command or data</p>
<h4 id="Standard-I2C-Protocol"><a href="#Standard-I2C-Protocol" class="headerlink" title="Standard I2C Protocol"></a>Standard I2C Protocol</h4><h5 id="i2c-master-send"><a href="#i2c-master-send" class="headerlink" title="i2c_master_send"></a>i2c_master_send</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S Addr Wr [A] Data [A] Data [A] ... [A] Data [A] P</span><br></pre></td></tr></table></figure>
<p>i2c_master_send()，向slave device发送count字节的数据</p>
<p><img src="/images/i2c/14824596543903.jpg" alt="i2c_send-c400"></p>
<h5 id="i2c-master-recv"><a href="#i2c-master-recv" class="headerlink" title="i2c_master_recv"></a>i2c_master_recv</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S Addr Rd [A] [Data] A [Data] A ... A [Data] NA P</span><br></pre></td></tr></table></figure>
<p>i2c_master_recv()，从slave device接收count字节的数据</p>
<p><img src="/images/i2c/14824596955160.jpg" alt="i2c_receive-c400"></p>
<h5 id="i2c-transfer"><a href="#i2c-transfer" class="headerlink" title="i2c_transfer"></a>i2c_transfer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S Addr Rd [A] [Data] NA S Addr Wr [A] Data [A] P</span><br></pre></td></tr></table></figure>
<p>i2c_transfer()，根据传入的多个i2c message进行多次i2c数据传输</p>
<p><img src="/images/i2c/14824597244531.jpg" alt="i2c_transfer-c500"></p>
<h5 id="I2C-M-NOSTART"><a href="#I2C-M-NOSTART" class="headerlink" title="I2C_M_NOSTART"></a>I2C_M_NOSTART</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S Addr Rd [A] [Data] NA S Addr Wr [A] Data [A] P</span><br><span class="line">S Addr Rd [A] [Data] NA Data [A] P</span><br></pre></td></tr></table></figure>
<p>在进行读写混合操作时，当指定第二个i2c_msg的flags标志位为I2C_M_NOSTART时，实际传输时会忽略第二个message的起始信号 S Addr Rd/Wr；第一个i2c_msg的flags标志位通常不能设置为I2C_M_NOSTART时</p>
<p>需要i2c_algorithm的I2C_FUNC_NOSTART支持</p>
<h5 id="I2C-M-IGNORE-NAK"><a href="#I2C-M-IGNORE-NAK" class="headerlink" title="I2C_M_IGNORE_NAK"></a>I2C_M_IGNORE_NAK</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S Addr Wr [A] Data [A] Data [NA] Data [A] ... [A] Data [A] P</span><br></pre></td></tr></table></figure>
<p>数据传输过程中忽略从设备的NA信号，直至将所有的i2c message发送完成，需要i2c_algorithm的I2C_FUNC_PROTOCOL_MANGLING支持</p>
<h5 id="I2C-M-REV-DIR-ADDR"><a href="#I2C-M-REV-DIR-ADDR" class="headerlink" title="I2C_M_REV_DIR_ADDR"></a>I2C_M_REV_DIR_ADDR</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S Addr Rd [A] Data [A] Data [A] ... [A] Data [A] P</span><br></pre></td></tr></table></figure>
<p>将读写信号Rd/Wr翻转，即此时Rd信号表示写操作，Wr信号表示读操作，需要i2c_algorithm的I2C_FUNC_PROTOCOL_MANGLING支持，需要i2c_algorithm的I2C_FUNC_PROTOCOL_MANGLING支持</p>
<h5 id="I2C-M-STOP"><a href="#I2C-M-STOP" class="headerlink" title="I2C_M_STOP"></a>I2C_M_STOP</h5><p>一次i2c message传输完成后强制发送结束信号P，需要i2c_algorithm的I2C_FUNC_PROTOCOL_MANGLING支持</p>
<h5 id="I2C-M-NO-RD-ACK"><a href="#I2C-M-NO-RD-ACK" class="headerlink" title="I2C_M_NO_RD_ACK"></a>I2C_M_NO_RD_ACK</h5><p>读操作的时候忽略所有的ACK/NACK信号</p>
<h4 id="SMBus-Protocol"><a href="#SMBus-Protocol" class="headerlink" title="SMBus Protocol"></a>SMBus Protocol</h4><p>SMBus (System Management Bus) 是I2C协议的一个sibling protocol，但SMBus Protocol的电气特性更加严格，而standard I2C Protocol则更为通用，因而通常可以使用标准I2C bus模拟 SMBus，即标准 I2C 协议兼容SMBus协议，但SMBus协议不兼容标准I2C协议</p>
<p>有些I2C controller只支持SMBus协议，而不支持标准I2C协议，而支持标准I2C协议的I2C controller通常也支持SMBus协议，因而为了提高驱动的可移植性，应尽可能使用SMBus协议进行数据传输</p>
<h5 id="Packet-Error-Checking-PEC"><a href="#Packet-Error-Checking-PEC" class="headerlink" title="Packet Error Checking (PEC)"></a>Packet Error Checking (PEC)</h5><p>PEC 在停止位P之前增加一个CRC-8 error-checking byte，以对传输的数据进行校验</p>
<h5 id="I2C-FUNC-SMBUS-QUICK"><a href="#I2C-FUNC-SMBUS-QUICK" class="headerlink" title="I2C_FUNC_SMBUS_QUICK"></a>I2C_FUNC_SMBUS_QUICK</h5><p>I2C_FUNC_SMBUS_QUICK = I2C_SMBUS_WRITE I2C_SMBUS_QUICK</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A Addr Rd/Wr [A] P</span><br></pre></td></tr></table></figure>
<p>只向slave device发送一个 Rd/Wr bit，通常用于判断指定i2c地址处是否有相应的i2c设备存在</p>
<p><img src="/images/i2c/14867036827105.jpg" alt="quick_command-c250"></p>
<h5 id="I2C-FUNC-SMBUS-READ-BYTE"><a href="#I2C-FUNC-SMBUS-READ-BYTE" class="headerlink" title="I2C_FUNC_SMBUS_READ_BYTE"></a>I2C_FUNC_SMBUS_READ_BYTE</h5><p>I2C_FUNC_SMBUS_READ_BYTE = I2C_SMBUS_READ I2C_SMBUS_BYTE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S Addr Rd [A] [Data] NA P</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_read_byte()，只从slave device读取一个字节的数据，而不指定需要读取的寄存器的地址，通常用于一些结构非常简单的slave device或在之前的i2c message中已经指定该寄存器的地址</p>
<p><img src="/images/i2c/14867038239038.jpg" alt="read_byte-c450"></p>
<h5 id="I2C-FUNC-SMBUS-WRITE-BYTE"><a href="#I2C-FUNC-SMBUS-WRITE-BYTE" class="headerlink" title="I2C_FUNC_SMBUS_WRITE_BYTE"></a>I2C_FUNC_SMBUS_WRITE_BYTE</h5><p>I2C_FUNC_SMBUS_WRITE_BYTE = I2C_SMBUS_WRITE I2C_SMBUS_BYTE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S Addr Wr [A] Data [A] P</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_write_byte()，只向slave device写入一个字节的数据，而不指定需要读取的寄存器的地址</p>
<p><img src="/images/i2c/14867037352403.jpg" alt="write_byte-c450"></p>
<h5 id="I2C-FUNC-SMBUS-READ-BYTE-DATA"><a href="#I2C-FUNC-SMBUS-READ-BYTE-DATA" class="headerlink" title="I2C_FUNC_SMBUS_READ_BYTE_DATA"></a>I2C_FUNC_SMBUS_READ_BYTE_DATA</h5><p>I2C_FUNC_SMBUS_READ_BYTE_DATA = I2C_SMBUS_READ I2C_SMBUS_BYTE_DATA</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S Addr Wr [A] Comm [A] S Addr Rd [A] [Data] NA P</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_read_byte_data()，从slave device的特定寄存器读取一个字节的数据，寄存器的地址由Comm指定</p>
<p><img src="/images/i2c/14867041597629.jpg" alt="read_byte_data-c550"></p>
<h5 id="I2C-FUNC-SMBUS-WRITE-BYTE-DATA"><a href="#I2C-FUNC-SMBUS-WRITE-BYTE-DATA" class="headerlink" title="I2C_FUNC_SMBUS_WRITE_BYTE_DATA"></a>I2C_FUNC_SMBUS_WRITE_BYTE_DATA</h5><p>I2C_FUNC_SMBUS_WRITE_BYTE_DATA = I2C_SMBUS_WRITE I2C_SMBUS_BYTE_DATA</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S Addr Wr [A] Comm [A] Data [A] P</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_write_byte_data()，向slave device的特定寄存器写入一个字节的数据，寄存器的地址由Comm指定</p>
<p><img src="/images/i2c/14867040117290.jpg" alt="write_byte_data-c550"></p>
<h5 id="I2C-FUNC-SMBUS-READ-WORD-DATA"><a href="#I2C-FUNC-SMBUS-READ-WORD-DATA" class="headerlink" title="I2C_FUNC_SMBUS_READ_WORD_DATA"></a>I2C_FUNC_SMBUS_READ_WORD_DATA</h5><p>I2C_FUNC_SMBUS_READ_WORD_DATA = I2C_SMBUS_READ I2C_SMBUS_WORD_DATA</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S Addr Wr [A] Comm [A] S Addr Rd [A] [DataLow] A [DataHigh] NA P</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_read_word_data()，从slave device的特定寄存器读取一个字（word，16 bit）的数据，寄存器的地址由Comm指定</p>
<p><img src="/images/i2c/14867041338477.jpg" alt="read_word_data-c550"></p>
<h5 id="I2C-FUNC-SMBUS-WRITE-WORD-DATA"><a href="#I2C-FUNC-SMBUS-WRITE-WORD-DATA" class="headerlink" title="I2C_FUNC_SMBUS_WRITE_WORD_DATA"></a>I2C_FUNC_SMBUS_WRITE_WORD_DATA</h5><p>I2C_FUNC_SMBUS_WRITE_WORD_DATA = I2C_SMBUS_WRITE I2C_SMBUS_WORD_DATA</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S Addr Wr [A] Comm [A] DataLow [A] DataHigh [A] P</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_write_word_data()，向slave device的特定寄存器写入一个字（word，16 bit）的数据，寄存器的地址由Comm指定</p>
<p><img src="/images/i2c/14867039275306.jpg" alt="write_word_data-c550"></p>
<h5 id="I2C-FUNC-SMBUS-READ-BLOCK-DATA"><a href="#I2C-FUNC-SMBUS-READ-BLOCK-DATA" class="headerlink" title="I2C_FUNC_SMBUS_READ_BLOCK_DATA"></a>I2C_FUNC_SMBUS_READ_BLOCK_DATA</h5><p>I2C_FUNC_SMBUS_READ_BLOCK_DATA = I2C_SMBUS_READ I2C_SMBUS_BLOCK_DATA</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S Addr Wr [A] Comm [A] </span><br><span class="line">           S Addr Rd [A] [Count] A [Data] A [Data] A ... A [Data] NA P</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_read_block_data()，从slave device的特定寄存器读取一块数据（最多32 bytes），寄存器的地址由Comm指定</p>
<p><img src="/images/i2c/14867042412870.jpg" alt="read_block_data-c550"></p>
<h5 id="I2C-FUNC-SMBUS-WRITE-BLOCK-DATA"><a href="#I2C-FUNC-SMBUS-WRITE-BLOCK-DATA" class="headerlink" title="I2C_FUNC_SMBUS_WRITE_BLOCK_DATA"></a>I2C_FUNC_SMBUS_WRITE_BLOCK_DATA</h5><p>I2C_FUNC_SMBUS_WRITE_BLOCK_DATA = I2C_SMBUS_WRITE I2C_SMBUS_BLOCK_DATA</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S Addr Wr [A] Comm [A] Count [A] Data [A] Data [A] ... [A] Data [A] P</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_write_block_data()，向slave device的特定寄存器写入一块数据（最多32 bytes），寄存器的地址由Comm指定</p>
<p><img src="/images/i2c/14867042641537.jpg" alt="write_block_data-c550"></p>
<h5 id="I2C-FUNC-SMBUS-PROC-CALL"><a href="#I2C-FUNC-SMBUS-PROC-CALL" class="headerlink" title="I2C_FUNC_SMBUS_PROC_CALL"></a>I2C_FUNC_SMBUS_PROC_CALL</h5><p>I2C_FUNC_SMBUS_PROC_CALL = I2C_SMBUS_READ I2C_SMBUS_PROC_CALL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S Addr Wr [A] Comm [A] DataLow [A] DataHigh [A] </span><br><span class="line">                             S Addr Rd [A] [DataLow] A [DataHigh] NA P</span><br></pre></td></tr></table></figure>
<p>SMBus Process Call用于向特定寄存器写入16 bit数据，之后再从该寄存器读取16 bit数据，寄存器的地址由Comm指定</p>
<p><img src="/images/i2c/14867063624610.jpg" alt="process_call-c550"></p>
<h5 id="I2C-FUNC-SMBUS-BLOCK-PROC-CALL"><a href="#I2C-FUNC-SMBUS-BLOCK-PROC-CALL" class="headerlink" title="I2C_FUNC_SMBUS_BLOCK_PROC_CALL"></a>I2C_FUNC_SMBUS_BLOCK_PROC_CALL</h5><p>I2C_FUNC_SMBUS_BLOCK_PROC_CALL = I2C_SMBUS_READ I2C_SMBUS_BLOCK_PROC_CALL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S Addr Wr [A] Comm [A] Count [A] Data [A] ...</span><br><span class="line">                             S Addr Rd [A] [Count] A [Data] ... A P</span><br></pre></td></tr></table></figure>
<p>BlockWrite - BlockRead Process Call向特定寄存器写入1~32 bytes数据，之后再从该寄存器读取1~32 bytes数据，寄存器的地址由Comm指定</p>
<p><img src="/images/i2c/14867068559951.jpg" alt="block_write_block_read_process_call-c600"></p>
<h5 id="SMBus-Host-Notify"><a href="#SMBus-Host-Notify" class="headerlink" title="SMBus Host Notify"></a>SMBus Host Notify</h5><p>SMBus Host Notify用于当一个SMBus device成为master device时，由该master device向host device（通常为SMBus controller）发送 16 bit 的数据，即alerting事件</p>
<p>host device是指specialized master device，即与CPU直接相连的master device</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[S] [HostAddr] [Wr] A [DevAddr] A [DataLow] A [DataHigh] A [P]</span><br></pre></td></tr></table></figure>
<p>其中HostAddr为host device的地址，DevAddr为slave device的地址</p>
<p><img src="/images/i2c/14867070346714.jpg" alt="host_notify-c550"></p>
<h5 id="I2C-FUNC-SMBUS-READ-I2C-BLOCK"><a href="#I2C-FUNC-SMBUS-READ-I2C-BLOCK" class="headerlink" title="I2C_FUNC_SMBUS_READ_I2C_BLOCK"></a>I2C_FUNC_SMBUS_READ_I2C_BLOCK</h5><p>I2C_FUNC_SMBUS_READ_I2C_BLOCK = I2C_SMBUS_READ I2C_SMBUS_I2C_BLOCK_DATA</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S Addr Wr [A] Comm [A] </span><br><span class="line">           S Addr Rd [A] [Data] A [Data] A ... A [Data] NA P</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_read_i2c_block_data()，由于standard I2C protocol自身以字节为单位进行数据传输，因而通过SMBus layer实现I2C block data数据传输，从slave device的特定寄存器读取一块数据，寄存器的地址由Comm指定</p>
<p>I2C block data本身不存在字节数的限制，然而由于SMBus protocol的block data存在32 bytes的限制，因而通过SMBus layer实现I2C block data数据传输时I2C block data也被限制为最多32个字节</p>
<h5 id="I2C-FUNC-SMBUS-WRITE-I2C-BLOCK"><a href="#I2C-FUNC-SMBUS-WRITE-I2C-BLOCK" class="headerlink" title="I2C_FUNC_SMBUS_WRITE_I2C_BLOCK"></a>I2C_FUNC_SMBUS_WRITE_I2C_BLOCK</h5><p>I2C_FUNC_SMBUS_WRITE_I2C_BLOCK = I2C_SMBUS_WRITE I2C_FUNC_SMBUS_WRITE_I2C_BLOCK</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S Addr Wr [A] Comm [A] Data [A] Data [A] ... [A] Data [A] P</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_write_i2c_block_data()，通过SMBus layer实现I2C block data数据传输，向slave device的特定寄存器写入一块数据（不存在32 bytes的限制），寄存器的地址由Comm指定</p>
<h2 id="I2C-Framework"><a href="#I2C-Framework" class="headerlink" title="I2C Framework"></a>I2C Framework</h2><p><img src="/images/i2c/i2c_sw_topology.png" alt="i2c_sw_topology-c600"></p>
<ol>
<li><p>I2C Controller<br>每个 I2C Controller 都作为一个 platform device 挂载在 platform bus 上，并对应一个 platform driver<br>platform bus 通常用于挂载与CPU通过系统总线直接连接的外设</p>
</li>
<li><p>I2C Slave Device<br>I2C Core 抽象出 I2C Bus 用来挂载所有与 I2C Controller 通过 I2C 总线相连接的 I2C Slave Device</p>
</li>
<li><p>I2C Adapter<br>I2C Core 抽象出一个虚拟实体 I2C Adapter（i2c_adapter, /sys/bus/i2c/devices/i2c-n）用于抽象 I2C Controller 关于数据收发的功能，I2C Adapter 挂载在 I2C Bus 上</p>
</li>
</ol>
<p>相关的数据结构与sysfs entry有</p>
<ol>
<li><p>platform bus</p>
<ul>
<li>struct bus_type platform_bus_type</li>
<li>/sys/bus/platform</li>
</ul>
</li>
<li><p>I2C Bus</p>
<ul>
<li>struct bus_type i2c_bus_type</li>
<li>/sys/bus/i2c</li>
</ul>
</li>
<li><p>I2C Controller</p>
<ul>
<li>/sys/bus/platform/devices/xxxxxxxx.i2c</li>
</ul>
</li>
<li><p>I2C Adapter</p>
<ul>
<li>struct i2c_adapter</li>
<li>/sys/bus/i2c/devices/i2c-n</li>
</ul>
</li>
<li><p>I2C Slave Device</p>
<ul>
<li>struct i2c_client</li>
<li>/sys/bus/i2c/devices/n-xx</li>
</ul>
</li>
</ol>
<p>I2C Framework 分为 I2C core、I2C buses、I2C algos 与 I2C muxes 四部分</p>
<ol>
<li><p>I2C core<br>I2C core 使用 I2C adapter 与 I2C algorithm 抽象 I2C controller，<br>使用 I2C client 与 I2C driver 抽象 I2C slave device，<br>同时实现 smbus 协议</p>
</li>
<li><p>I2C buses<br>I2C buses 是各个 I2C controller driver 的集合</p>
</li>
<li><p>I2C algos<br>I2C algos 是一些通用的 I2C algorithm 的集合，I2C algorithm 定义 I2C 协议包的生成方法，通常是硬件相关的，每个 I2C controller 都必须与一个 I2C algorithm 唯一对应</p>
</li>
<li><p>I2C muxes<br>I2C muxes 实现 I2C buse 的多路复用功能</p>
</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="i2c-adapter"><a href="#i2c-adapter" class="headerlink" title="i2c_adapter"></a>i2c_adapter</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line"> * i2c_adapter is the structure used to identify a physical i2c bus along</span><br><span class="line"> * with the access algorithms necessary to access it.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">struct</span> i2c_adapter &#123;</span><br><span class="line">	<span class="keyword">struct</span> module *owner;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">class</span>;		  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> i2c_algorithm *algo; <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">	<span class="keyword">void</span> *algo_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* data fields that are valid for all devices */</span></span><br><span class="line">	<span class="keyword">struct</span> rt_mutex bus_lock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> timeout;			<span class="comment">/* in jiffies */</span></span><br><span class="line">	<span class="keyword">int</span> retries;</span><br><span class="line">	<span class="keyword">struct</span> device dev;		<span class="comment">/* the adapter device */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> cancel_xfer_on_shutdown;</span><br><span class="line">	<span class="keyword">bool</span> atomic_xfer_only;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> nr;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">48</span>];</span><br><span class="line">	<span class="keyword">struct</span> completion dev_released;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> mutex userspace_clients_lock;</span><br><span class="line">	<span class="keyword">struct</span> list_head userspace_clients;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> i2c_bus_recovery_info *bus_recovery_info;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> bus_clk_rate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>i2c_adapter 用于抽象 I2C controller 数据收发的功能，标识物理的 I2C 总线</p>
<p>@name       该i2c controller的名称<br>@nr         该i2c controller对应的I2C bus ID<br>@dev        该i2c controller对应的device<br>@algo       该I2C controller对应的 i2c algorithm<br>@algo_data  i2c algorithm使用的数据，在i2c mux机制中该字段用于存储i2c_mux_priv结构，在bit-banging algorithm中该字段用于存储i2c_algo_bit_data结构</p>
<p>@retries    I2C 数据包传输失败时允许重发，retries字段规定允许重发的次数<br>@timeout    timeout字段规定允许重发的超时时间，当数据传输过程超过该超时时间时函数不再尝试重发</p>
<p>@userspace_clients  该 adapter 下挂载的所有 i2c_client 链表<br>@class              该 I2C controller 支持的 slave device 类型<br>@bus_lock           实现I2C bus独占性访问的mutex<br>@bus_clk_rate       该I2C bus clock rate<br>@cancel_xfer_on_shutdown    标志位，描述</p>
<p>class成员描述该i2c adapter支持的slave device类型</p>
<table>
<thead>
<tr>
<th>class</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>I2C_CLASS_HWMON</td>
<td>硬件监控类，如lm_sensors</td>
</tr>
<tr>
<td>I2C_CLASS_DDC</td>
<td>显示设备的 DDC（Digital Display Chanel）</td>
</tr>
<tr>
<td>I2C_CLASS_SPD</td>
<td>存储设备</td>
</tr>
</tbody>
</table>
<h4 id="i2c-algorithm"><a href="#i2c-algorithm" class="headerlink" title="i2c_algorithm"></a>i2c_algorithm</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_algorithm &#123;</span><br><span class="line">	<span class="keyword">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs, <span class="keyword">int</span> num);</span><br><span class="line">	<span class="keyword">int</span> (*smbus_xfer) (<span class="keyword">struct</span> i2c_adapter *adap, u16 addr, <span class="keyword">unsigned</span> <span class="keyword">short</span> flags,</span><br><span class="line">	       <span class="keyword">char</span> read_write, u8 command, <span class="keyword">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">	u32 (*functionality) (<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>i2c_algorithm 用于抽象 I2C controller 的 I2C 协议</p>
<p>@functionality  该回调函数返回特定 I2C adapter 支持的功能<br>@master_xfer    standard I2C protocol的数据传输接口<br>@smbus_xfer     SMBus protocol的数据传输接口，当该接口未定义时使用standard I2C protocol模拟SMBus protocl</p>
<p>functionality()回调函数返回该i2c adapter支持的数据传输相关的功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_I2C                    0x00000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_10BIT_ADDR             0x00000002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_PROTOCOL_MANGLING      0x00000004 <span class="comment">/* I2C_M_IGNORE_NAK etc. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_PEC              0x00000008</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_NOSTART                0x00000010 <span class="comment">/* I2C_M_NOSTART */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_BLOCK_PROC_CALL  0x00008000 <span class="comment">/* SMBus 2.0 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_QUICK	           0x00010000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE        0x00020000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE       0x00040000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE_DATA   0x00080000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE_DATA  0x00100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_READ_WORD_DATA   0x00200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_WRITE_WORD_DATA  0x00400000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_PROC_CALL        0x00800000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_READ_BLOCK_DATA  0x01000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_WRITE_BLOCK_DATA 0x02000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_READ_I2C_BLOCK   0x04000000 <span class="comment">/* I2C-like block xfer  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_WRITE_I2C_BLOCK  0x08000000 <span class="comment">/* w/ 1-byte reg. addr. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_I2C_SLAVE_SUPPORT      0x10000000 <span class="comment">/* i2c slave support */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_BYTE		(I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_BYTE_DATA	(I2C_FUNC_SMBUS_READ_BYTE_DATA | I2C_FUNC_SMBUS_WRITE_BYTE_DATA)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_WORD_DATA	(I2C_FUNC_SMBUS_READ_WORD_DATA | I2C_FUNC_SMBUS_WRITE_WORD_DATA)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_BLOCK_DATA	(I2C_FUNC_SMBUS_READ_BLOCK_DATA | I2C_FUNC_SMBUS_WRITE_BLOCK_DATA)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_I2C_BLOCK	(I2C_FUNC_SMBUS_READ_I2C_BLOCK | I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_FUNC_SMBUS_EMUL		(I2C_FUNC_SMBUS_QUICK | \</span><br><span class="line">					 I2C_FUNC_SMBUS_BYTE | \</span><br><span class="line">					 I2C_FUNC_SMBUS_BYTE_DATA | \</span><br><span class="line">					 I2C_FUNC_SMBUS_WORD_DATA | \</span><br><span class="line">					 I2C_FUNC_SMBUS_PROC_CALL | \</span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_BLOCK_DATA | \</span><br><span class="line">					 I2C_FUNC_SMBUS_I2C_BLOCK | \</span><br><span class="line">					 I2C_FUNC_SMBUS_PEC)</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>I2C_FUNC_I2C</td>
<td>支持标准I2C协议</td>
</tr>
<tr>
<td>I2C_FUNC_10BIT_ADDR</td>
<td>支持10 bit地址</td>
</tr>
<tr>
<td>I2C_FUNC_PROTOCOL_MANGLING</td>
<td>支持非标准的I2C协议</td>
</tr>
<tr>
<td>I2C_FUNC_NOSTART</td>
<td>支持不需要发送START信号的I2C传输，可以用于bulk register read/write</td>
</tr>
<tr>
<td>I2C_FUNC_SMBUS_xxx</td>
<td>支持SMBus协议</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u32 <span class="title">i2c_get_functionality</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> adap-&gt;algo-&gt;functionality(adap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_get_functionality()函数返回特定 I2C adapter 支持的功能</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline int i2c_check_functionality(struct i2c_adapter *adap, u32 func)</span><br><span class="line">&#123;</span><br><span class="line">	return (func &amp; i2c_get_functionality(adap)) == func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_check_functionality()函数可以检查特定adapter是否支持特定功能func，若支持函数返回1，否则返回0</p>
<h4 id="i2c-client"><a href="#i2c-client" class="headerlink" title="i2c_client"></a>i2c_client</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_client &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> flags;	<span class="comment">/* div., see below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> addr;		<span class="comment">/* chip address - <span class="doctag">NOTE:</span> 7bit */</span></span><br><span class="line">					<span class="comment">/* addresses are stored in the _LOWER_ 7 bits */</span></span><br><span class="line">	<span class="keyword">char</span> name[I2C_NAME_SIZE];</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *adapter;  <span class="comment">/* the adapter we sit on */</span>	</span><br><span class="line">	<span class="keyword">struct</span> i2c_driver *driver;	    <span class="comment">/* and our access routines */</span></span><br><span class="line">	<span class="keyword">struct</span> device dev;		       <span class="comment">/* the device structure */</span></span><br><span class="line">	<span class="keyword">int</span> irq;			                <span class="comment">/* irq issued by device */</span></span><br><span class="line">	<span class="keyword">struct</span> list_head detected;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>i2c_client 抽象 I2C slave device</p>
<p>@flags      标志位，描述该 slave device的一些特性<br>@addr       该slave device的7-bit地址<br>@name       该slave device名称<br>@adapter    该slave device所属的i2c_adapter<br>@driver     该slave device的i2c_driver<br>@dev        该slave device对应的device<br>@irq        该slave device的interrupt number<br>@detected   通过该链表头组织</p>
<p>flags标志位的值有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_CLIENT_PEC      0x04    <span class="comment">/* Use Packet Error Checking */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_CLIENT_TEN      0x10    <span class="comment">/* we have a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_CLIENT_WAKE     0x80    <span class="comment">/* for board_info; true iff can wake */</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>I2C_CLIENT_PEC</td>
<td>支持 SMBus Packet Error Checking</td>
</tr>
<tr>
<td>I2C_CLIENT_TEN</td>
<td>该设备使用10-bit address</td>
</tr>
<tr>
<td>I2C_CLIENT_WAKE</td>
<td>该设备具有wakeup的能力</td>
</tr>
</tbody>
</table>
<h4 id="i2c-driver"><a href="#i2c-driver" class="headerlink" title="i2c_driver"></a>i2c_driver</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_driver &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">class</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*attach_adapter)(<span class="keyword">struct</span> i2c_adapter *) __deprecated;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *);</span><br><span class="line">	<span class="keyword">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line">	<span class="keyword">int</span> (*suspend)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">pm_message_t</span> mesg);</span><br><span class="line">	<span class="keyword">int</span> (*resume)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">unsigned</span> <span class="keyword">int</span> data);</span><br><span class="line">	<span class="keyword">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> device_driver driver;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *id_table;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">struct</span> i2c_board_info *);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> *address_list;</span><br><span class="line">	<span class="keyword">struct</span> list_head clients;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>i2c_driver 抽象 I2C driver，即I2C slave device driver</p>
<p>@class          该i2c_driver支持的设备类型<br>@driver         该i2c_driver对应的device_driver<br>@id_table       该i2c_driver支持的i2c_device_id列表<br>@address_list   该i2c_driver支持的i2c地址列表<br>@clients        该i2c_driver的i2c_client链表</p>
<p>address_list成员描述该i2c driver支持的i2c address table，其数组的最后一个元素应为I2C_CLIENT_END</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_CLIENT_END		0xfffeU</span></span><br></pre></td></tr></table></figure>
<p>I2C_ADDRS()宏可以用于设置i2c driver的address_list</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_ADDRS(addr, addrs...) \</span><br><span class="line">	((const unsigned short [])&#123; addr, ## addrs, I2C_CLIENT_END &#125;)</span></span><br></pre></td></tr></table></figure>
<h4 id="i2c-devinfo"><a href="#i2c-devinfo" class="headerlink" title="i2c_devinfo"></a>i2c_devinfo</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_devinfo &#123;</span><br><span class="line">	<span class="keyword">struct</span> list_head	<span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">int</span>			busnum;</span><br><span class="line">	<span class="keyword">struct</span> i2c_board_info	board_info;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>i2c_devinfo抽象slave device的相关信息，内核为设备树或板级文件中描述的每个slave device分配一个i2c_devinfo结构，并用全局链表__i2c_board_list保存所有的i2c_devinfo</p>
<p>@list       __i2c_board_list全局链表保存了所有的i2c_devinfo，该i2c_devinfo通过该list字段访问该链表<br>@busnum     该slave device所属的i2c bus<br>@board_info 该i2c_devinfo的i2c_board_info，其中保存该slave device的相关信息</p>
<h4 id="i2c-board-info"><a href="#i2c-board-info" class="headerlink" title="i2c_board_info"></a>i2c_board_info</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_board_info &#123;</span><br><span class="line">	<span class="keyword">char</span>		type[I2C_NAME_SIZE];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>	flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>	addr;</span><br><span class="line">	<span class="keyword">void</span>		*platform_data;</span><br><span class="line">	<span class="keyword">struct</span> dev_archdata	*archdata;</span><br><span class="line">	<span class="keyword">struct</span> device_node *of_node;</span><br><span class="line">	<span class="keyword">struct</span> acpi_dev_node acpi_node;</span><br><span class="line">	<span class="keyword">int</span>		irq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>i2c_board_info抽象slave device的相关信息，通常用于初始化i2c_client实例</p>
<p>@type           该slave device的名称，对应于i2c_client.name<br>@flags          该slave device的标志位 ，对应于i2c_client.flags<br>@addr           该slave device的地址，对应于i2c_client.addr<br>@platform_data  该slave device的platform data，保存在i2c_client.dev.platform_data<br>@archdata       该slave device的arch data，保存在i2c_client.dev.archdata<br>@of_node        该slave device的设备节点<br>@irq            该slave device的interrupt number，对应于i2c_client.irq</p>
<h4 id="i2c-device-id"><a href="#i2c-device-id" class="headerlink" title="i2c_device_id"></a>i2c_device_id</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_device_id &#123;</span><br><span class="line">	<span class="keyword">char</span> name[I2C_NAME_SIZE];</span><br><span class="line">	<span class="keyword">kernel_ulong_t</span> driver_data;	<span class="comment">/* Data private to the driver */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct i2c_device_id抽象i2c device id</p>
<p>i2c driver的id_table成员存储该i2c driver支持的i2c device id table，在i2c client与i2c driver的match过程中遍历i2c device id table中的所有i2c device id，并简单地判断i2c_device_id的名称与i2c_client的名称是否相等，若两者的名称相等则匹配成功</p>
<h4 id="i2c-msg"><a href="#i2c-msg" class="headerlink" title="i2c_msg"></a>i2c_msg</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_msg &#123;</span><br><span class="line">	__u16 addr;	<span class="comment">/* slave address */</span></span><br><span class="line">	__u16 flags;	</span><br><span class="line">	__u16 len;		<span class="comment">/* msg length */</span></span><br><span class="line">	__u8 *buf;		<span class="comment">/* pointer to msg data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct i2c_msg抽象 I2C 数据包，I2C协议以 i2c_msg 为单位进行数据传输，一个i2c message可以包含多个字节的数据</p>
<p>@addr       I2C slave device 的地址<br>@flags      I2C message的标志位<br>@len        数据传输的长度，以 byte 为单位<br>@buf        用于存储需要写入的数据或读取的数据的buf</p>
<p>flags字段的值有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_TEN	           0x0010 <span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RD            0x0001 <span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_STOP          0x8000 <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NOSTART       0x4000 <span class="comment">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_REV_DIR_ADDR  0x2000 <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_IGNORE_NAK	  0x1000 <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_NO_RD_ACK	  0x0800 <span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_M_RECV_LEN		  0x0400 <span class="comment">/* length will be first received byte */</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>I2C_M_TEN</td>
<td>支持 10-bit slave device 地址</td>
</tr>
<tr>
<td>I2C_M_RD</td>
<td>此次传输为读操作，from slave to master，若不包含该标志，则此次传输为写操作</td>
</tr>
</tbody>
</table>
<p>standard I2C数据传输以i2c message为单位，i2c_msg的flags标志位中的I2C_M_RD标志描述该i2c message传输的方向，若flags标志位中包含I2C_M_RD标志则此次i2 message传输方向为slave -&gt; master，否则其传输方向为master -&gt; slave</p>
<h4 id="i2c-smbus-data"><a href="#i2c-smbus-data" class="headerlink" title="i2c_smbus_data"></a>i2c_smbus_data</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> i2c_smbus_data &#123;</span><br><span class="line">	__u8 byte;</span><br><span class="line">	__u16 word;</span><br><span class="line">	__u8 block[I2C_SMBUS_BLOCK_MAX + <span class="number">2</span>]; <span class="comment">/* block[0] is used for length */</span></span><br><span class="line">			       <span class="comment">/* and one more for user-space compatibility */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SMBus protocol数据传输以i2c_smbus_data为单位，一个i2c_smbus_data可以是一个字节byte，或一个字word（即2 bytes），也可以是一个数据块block（max 32 bytes）</p>
<p>当一次传输一个数据块（即一组字节）时，block[]数组描述需要传输的数据块，其中block[0]描述有效数据块（包括block[1]，但不包括blobk[0]）的长度，其余的元素为需要传输的数据，其中block[1]表示user-specific data，单次传输的数据块的大小限制为I2C_SMBUS_BLOCK_MAX，即32个字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_SMBUS_BLOCK_MAX	32  <span class="comment">/* As specified in SMBus standard */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="I2C-framework-init"><a href="#I2C-framework-init" class="headerlink" title="I2C framework init"></a>I2C framework init</h3><p>i2c 子系统的初始化顺序为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i2c core init 即 i2c_init</span><br><span class="line">    -&gt; board-specific init 即 &lt;board_spec&gt;_machine_desc -&gt; init_machine</span><br><span class="line">        -&gt; i2c adapter driver init</span><br><span class="line">            -&gt; i2c dev init</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>顺序</th>
<th>函数</th>
<th>initcall</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>i2c_init</td>
<td>postcore_initcall(i2c_init);</td>
<td>drivers/i2c/i2c-core.c</td>
</tr>
<tr>
<td>2</td>
<td><board_spec>_machine_desc -&gt; init_machine (tegra_t210ref_dt_init)</board_spec></td>
<td>arch_initcall()</td>
<td>arch/arm64/mach-tegra/board-t210ref.c</td>
</tr>
<tr>
<td>3</td>
<td><controller_spec>_i2c_init_driver (tegra_i2c_init_driver)</controller_spec></td>
<td>subsys_initcall(tegra_i2c_init_driver)</td>
<td>drivers/i2c/buses/i2c-tegra.c</td>
</tr>
<tr>
<td>4</td>
<td>i2c_dev_init</td>
<td>module_init(i2c_dev_init)</td>
<td>drivers/i2c/i2c-dev.c</td>
</tr>
</tbody>
</table>
<p>在目标板的初始化代码中，对设备树及板级文件进行处理，对每个i2c bus维护一个i2c_board_info数组，数组中的每个i2c_board_info描述一个对应的slave device，之后在i2c子系统的初始化过程中对每个i2c bus调用i2c_register_board_info，为该i2c bus下的每个i2c_board_info分配对应的i2c_devinfo结构体，并将所有的i2c_devinfo添加到__i2c_board_list全局链表中</p>
<h5 id="I2C-core-init"><a href="#I2C-core-init" class="headerlink" title="I2C core init"></a>I2C core init</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">i2c_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">	retval = bus_register(&amp;i2c_bus_type);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">	i2c_first_dynamic_bus_num_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class="line">	i2c_adapter_compat_class = class_compat_register(<span class="string">"i2c-adapter"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!i2c_adapter_compat_class) &#123;</span><br><span class="line">		retval = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> bus_err;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	retval = i2c_add_driver(&amp;dummy_driver);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> class_err;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">class_err:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class="line">	class_compat_unregister(i2c_adapter_compat_class);</span><br><span class="line">bus_err:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">postcore_initcall(i2c_init);</span><br></pre></td></tr></table></figure>
<p>i2c_init()完成i2c core的初始化</p>
<ul>
<li>调用bus_register()注册i2c_bus_type</li>
<li>调用i2c_first_dynamic_bus_num_init()初始化__i2c_first_dynamic_bus_num变量</li>
</ul>
<h5 id="board-specific-init"><a href="#board-specific-init" class="headerlink" title="board-specific init"></a>board-specific init</h5><p>tegra_t210ref_dt_init()完成board-specific i2c framework的初始化，其中调用bus_register_notifier()注册i2c_bus_type的通知链，之后对i2c时钟进行设置</p>
<h5 id="i2c-adapter-driver-register"><a href="#i2c-adapter-driver-register" class="headerlink" title="i2c adapter driver register"></a>i2c adapter driver register</h5><p>由于 i2c controller 作为 platform device，因而<code>drivers/i2c/buses</code>下存放各个 i2c controller 的 platform driver</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">tegra_i2c_init_driver</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;tegra_i2c_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c adapter driver为tegra_i2c_driver</p>
<p>内核初始化阶段对设备树进行解析，将i2c controller作为platform device挂载到platform_bus_type bus，同时tegra_i2c_init_driver()函数将platform_driver挂载到platform_bus_type bus，当匹配成功时执行platform_driver的probe函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> platform_driver tegra_i2c_driver = &#123;</span><br><span class="line">	.probe   = tegra_i2c_probe,</span><br><span class="line">	.remove  = tegra_i2c_remove,</span><br><span class="line">	.late_shutdown = tegra_i2c_shutdown,</span><br><span class="line">	.id_table = tegra_i2c_devtype,</span><br><span class="line">	.driver  = &#123;</span><br><span class="line">		.name  = <span class="string">"tegra-i2c"</span>,</span><br><span class="line">		.owner = THIS_MODULE,</span><br><span class="line">		.of_match_table = of_match_ptr(tegra_i2c_of_match),</span><br><span class="line">		.pm    = TEGRA_I2C_PM,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tegra_i2c_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br></pre></td></tr></table></figure>
<p>tegra_i2c_probe()完成i2c adapter的初始化</p>
<ul>
<li>分配并初始化一个tegra_i2c_dev结构，为该结构分配一些系统资源</li>
<li>初始化tegra_i2c_dev的i2c_adapter成员，设置i2c_adapter的bus ID、algorithm等</li>
<li>调用i2c_add_numbered_adapter()注册tegra_i2c_dev的i2c_adapter</li>
<li>调用of_i2c_register_devices()，为该i2c_adapter下的子设备节点创建一个i2c_board_info结构，其中调用i2c_new_device()根据i2c_board_info创建对应的i2c client</li>
</ul>
<h5 id="i2c-devinit"><a href="#i2c-devinit" class="headerlink" title="i2c devinit"></a>i2c devinit</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">i2c_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>i2c_dev_init()完成i2c dev init，其中完成 /dev 对应的字符设备的初始化，其操作集合为i2cdev_fops</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><h4 id="device-adding"><a href="#device-adding" class="headerlink" title="device adding"></a>device adding</h4><ol>
<li><p>在系统初始化的早期阶段，相应的i2c master通常尚未初始化，此时通常在板级文件中调用i2c_register_board_info()注册相应的i2c board info，在之后的相应的i2c master的初始化过程中，为注册的i2c board info创建对应的i2c client</p>
</li>
<li><p>i2c client driver的module init过程中，可以调用i2c_new_device()在相应的i2c master下根据特定i2c board info创建对应的i2c client</p>
</li>
<li><p>在设备树中定义i2c client，通常在设备树根节点下定义i2c master节点，同时定义i2c client节点作为i2c master节点的子节点；设备树解析过程中，将i2c master节点解析为platform device，在对应的platform driver中</p>
<ul>
<li>调用i2c_add_adapter()或i2c_add_numbered_adapter()注册相应的i2c master</li>
<li>调用of_i2c_register_devices()遍历i2c master节点的所有子节点，并为每个子节点注册对应的i2c device</li>
</ul>
</li>
</ol>
<h4 id="device-matching"><a href="#device-matching" class="headerlink" title="device matching"></a>device matching</h4><ol>
<li><p>若在设备树中定义i2c client，则首先实现of style的匹配，即遍历driver的of_match_table中的of device id table，若其中的一个of device id与device的of_node具有相同的name、type、compatible等属性，则成功匹配</p>
</li>
<li><p>之后调用i2c_match_id()实现i2c bus style匹配，i2c driver的id_table成员存储该i2c driver支持的i2c device id table，其匹配过程只是遍历i2c device id table中的所有i2c device id，并简单地判断i2c_device_id的名称与i2c_client的名称是否相等，若两者的名称相等则匹配成功</p>
</li>
</ol>
<h4 id="register-configuration"><a href="#register-configuration" class="headerlink" title="register configuration"></a>register configuration</h4><p>i2c protocol driver必须通过i2c controller通过i2c bus实现i2c device的寄存器配置，可以直接通过i2c message与i2c device进行通讯，也可以使用封装的regmap与i2c device进行通讯</p>
<h3 id="I2C-core"><a href="#I2C-core" class="headerlink" title="I2C core"></a>I2C core</h3><p><code>include/linux/i2c.h</code>与<code>drivers/i2c/i2c-core.c</code>定义 I2C core</p>
<h4 id="i2c-bus-operations"><a href="#i2c-bus-operations" class="headerlink" title="i2c bus operations"></a>i2c bus operations</h4><p>i2c core定义i2c bus，根据Linux Device Model，当i2c clien devicet或i2c driver注册到i2c bus时，调用i2c bus的match()实现新注册的i2c client device或i2c driver的匹配，之后调用i2c bus的probe()，其中调用i2c driver自身的probe()</p>
<h5 id="i2c-bus-type"><a href="#i2c-bus-type" class="headerlink" title="i2c_bus_type"></a>i2c_bus_type</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> bus_type i2c_bus_type = &#123;</span><br><span class="line">	.name		   = <span class="string">"i2c"</span>,</span><br><span class="line">	.match		= i2c_device_match,</span><br><span class="line">	.probe		= i2c_device_probe,</span><br><span class="line">	.remove		= i2c_device_remove,</span><br><span class="line">	.shutdown	= i2c_device_shutdown,</span><br><span class="line">	.pm		   = &amp;i2c_device_pm_ops,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所有注册的i2c client与i2c adapter均挂载在i2c bus上</p>
<p>i2c_bus_type 实现有probe()/remove()方法，因而probe过程中将调用i2c bus的probe()回调函数实现i2c device与i2c driver的binding</p>
<h5 id="i2c-device-match"><a href="#i2c-device-match" class="headerlink" title="i2c_device_match"></a>i2c_device_match</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_device_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_client	*client = i2c_verify_client(dev);</span><br><span class="line">	<span class="keyword">struct</span> i2c_driver	*driver;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attempt an OF style match */</span></span><br><span class="line">	<span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Then ACPI style match */</span></span><br><span class="line">	<span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	driver = to_i2c_driver(drv);</span><br><span class="line">	<span class="comment">/* match on an id table if there is one */</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> i2c_match_id(driver-&gt;id_table, client) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_device_match()实现i2c client与i2c driver的match</p>
<ul>
<li>调用of_driver_match_device()实现of style的匹配，遍历driver的of_match_table指向的of device id table，若其中的一个of device id与device的of_node具有相同的name、type、compatible等属性，则成功匹配</li>
<li>调用acpi_driver_match_device()进行ACPI style的匹配</li>
<li>调用i2c_match_id()实现i2c bus style匹配，i2c driver的id_table成员存储该i2c driver支持的i2c device id table，其匹配过程只是遍历i2c device id table中的所有i2c device id，并简单地判断i2c_device_id的名称与i2c_client的名称是否相等，若两者的名称相等则匹配成功</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *<span class="title">i2c_match_id</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_device_id *id,</span><br><span class="line">						<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (id-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(client-&gt;name, id-&gt;name) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> id;</span><br><span class="line">		id++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_match_id()返回i2c device id table中与i2c client同名的一个i2c device id</p>
<h5 id="i2c-device-probe"><a href="#i2c-device-probe" class="headerlink" title="i2c_device_probe"></a>i2c_device_probe</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_device_probe</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_client	*client = i2c_verify_client(dev);</span><br><span class="line">	<span class="keyword">struct</span> i2c_driver	*driver;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	driver = to_i2c_driver(dev-&gt;driver);</span><br><span class="line">	<span class="keyword">if</span> (!driver-&gt;probe || !driver-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	client-&gt;driver = driver;</span><br><span class="line">	<span class="keyword">if</span> (!device_can_wakeup(&amp;client-&gt;dev))</span><br><span class="line">		device_init_wakeup(&amp;client-&gt;dev,</span><br><span class="line">					client-&gt;flags &amp; I2C_CLIENT_WAKE);</span><br><span class="line">	dev_dbg(dev, <span class="string">"probe\n"</span>);</span><br><span class="line"></span><br><span class="line">	status = dev_pm_domain_attach(&amp;client-&gt;dev, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (status != -EPROBE_DEFER) &#123;</span><br><span class="line">		status = driver-&gt;probe(client, i2c_match_id(driver-&gt;id_table,</span><br><span class="line">					client));</span><br><span class="line">		<span class="keyword">if</span> (status)</span><br><span class="line">			dev_pm_domain_detach(&amp;client-&gt;dev, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_device_probe()实现i2c client与i2c driver的binding</p>
<ul>
<li>实行一些电源管理相关的初始化工作后，调用该device对应的i2c_driver的probe()方法</li>
</ul>
<h5 id="i2c-for-each-dev"><a href="#i2c-for-each-dev" class="headerlink" title="i2c_for_each_dev"></a>i2c_for_each_dev</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int i2c_for_each_dev(void *data, int (*fn)(struct device *, void *))</span><br><span class="line">&#123;</span><br><span class="line">	int res;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	res = bus_for_each_dev(&amp;i2c_bus_type, NULL, data, fn);</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_for_each_dev()遍历i2c bus的所有i2c device（包括i2c client与i2c adapetr），对于其中的每个i2c device调用fn()函数，data参数为fn()的参数</p>
<h4 id="i2c-adapter-driver-API"><a href="#i2c-adapter-driver-API" class="headerlink" title="i2c adapter driver API"></a>i2c adapter driver API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i2c_add_adapter / i2c_add_numbered_adapter</span><br><span class="line">    |_ i2c_register_adapter</span><br><span class="line">        |_ device_register</span><br><span class="line">        |_ i2c_scan_static_board_info</span><br><span class="line">        |_ __process_new_adapter</span><br><span class="line">            |_ i2c_do_add_adapter</span><br><span class="line">                |_ i2c_detect</span><br><span class="line">                    |_ i2c_detect_address</span><br><span class="line">                        |_ i2c_default_probe</span><br><span class="line">                        |_ i2c_driver-&gt;detect()</span><br><span class="line">                        |_ i2c_new_device</span><br></pre></td></tr></table></figure>
<p>i2c_add_adapter()为i2c adapter分配bus ID，并注册该i2c adapter，其注册过程中主要包括</p>
<ul>
<li>调用device_register()向device model注册该i2c adapter对应的device</li>
<li>调用i2c_scan_static_board_info()，在i2c adapter初始化之前在板级文件中可以静态定义i2c board info，其中的每个i2c board info都描述对应的i2c client device的相关信息，之后i2c adapter初始化时需要为其下的i2c board info创建对应的i2c client</li>
<li>遍历当前注册的i2c driver，对于每个i2c driver调用__process_new_adapter()为当前已经插入的i2c硬件设备创建对应的i2c client</li>
</ul>
<p>i2c driver的address_list成员保存该i2c driver支持的i2c client的地址列表，因而i2c adapter初始化过程中需要遍历所有当前注册的i2c driver的支持的i2c地址，在i2c_default_probe()调用中通过i2c_smbus_xfer()由该adapter向该i2c地址处发送一个i2c message，若该message收到回应则说明该地址处存在一个插入的可用i2c设备，因而需要为该i2c设备创建对应的i2c client</p>
<h5 id="i2c-add-adapter"><a href="#i2c-add-adapter" class="headerlink" title="i2c_add_adapter"></a>i2c_add_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> device *dev = &amp;adapter-&gt;dev;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">		id = of_alias_get_id(dev-&gt;of_node, <span class="string">"i2c"</span>);</span><br><span class="line">		<span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			adapter-&gt;nr = id;</span><br><span class="line">			<span class="keyword">return</span> __i2c_add_numbered_adapter(adapter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	id = idr_alloc(&amp;i2c_adapter_idr, adapter,</span><br><span class="line">		       __i2c_first_dynamic_bus_num, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line">	<span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line"></span><br><span class="line">	adapter-&gt;nr = id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i2c_register_adapter(adapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_add_adapter()为i2c adapter分配bus ID，并注册该i2c adapter，当已经在设备树中定义该i2c adapter的bus ID时，使用设备树中定义的bus ID，否则在所有未分配的bus ID中动态分配一个可用的bus ID</p>
<p>若注册成功则函数返回0，否则返回负的错误码</p>
<ul>
<li>当设备树中通过”i2c”属性定义该adapter的bus ID时，调用__i2c_add_numbered_adapter()注册adapter</li>
<li>否则调用idr_alloc()动态分配bus ID，并调用i2c_register_adapter()注册adapter</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __i2c_add_numbered_adapter(<span class="keyword">struct</span> i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span>	id;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	id = idr_alloc(&amp;i2c_adapter_idr, adap, adap-&gt;nr, adap-&gt;nr + <span class="number">1</span>,</span><br><span class="line">		       GFP_KERNEL);</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line">	<span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> id == -ENOSPC ? -EBUSY : id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i2c_register_adapter(adap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__i2c_add_numbered_adapter()注册指定bus ID的i2c adapter，指定的bus ID保存在adapter.nr中，但在调用该函数前尚未向i2c core申请分配该bus ID</p>
<ul>
<li>调用idr_alloc()分配指定的bus ID</li>
<li>调用i2c_register_adapter()注册该adapter</li>
</ul>
<h5 id="i2c-add-numbered-adapter"><a href="#i2c-add-numbered-adapter" class="headerlink" title="i2c_add_numbered_adapter"></a>i2c_add_numbered_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_add_numbered_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;nr == <span class="number">-1</span>) <span class="comment">/* -1 means dynamically assign bus id */</span></span><br><span class="line">		<span class="keyword">return</span> i2c_add_adapter(adap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __i2c_add_numbered_adapter(adap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_add_numbered_adapter()为i2c adapter分配bus ID，并注册该i2c adapter，此时该i2c adapter对应的bus ID已经保存在adapter.nr中</p>
<p>若注册成功则函数返回0，否则返回负的错误码</p>
<ul>
<li>当指定的bus ID为-1，即动态分配bus ID时，调用i2c_add_adapter()注册adapter</li>
<li>否则调用__i2c_add_numbered_adapter()注册adapter</li>
</ul>
<h5 id="i2c-register-adapter"><a href="#i2c-register-adapter" class="headerlink" title="i2c_register_adapter"></a>i2c_register_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_register_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Can't register until after driver model init */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(WARN_ON(!i2c_bus_type.p))) &#123;</span><br><span class="line">		res = -EAGAIN;</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Sanity checks */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(adap-&gt;name[<span class="number">0</span>] == <span class="string">'\0'</span>)) &#123;</span><br><span class="line">		pr_err(<span class="string">"i2c-core: Attempt to register an adapter with "</span></span><br><span class="line">		       <span class="string">"no name!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!adap-&gt;algo)) &#123;</span><br><span class="line">		pr_err(<span class="string">"i2c-core: Attempt to register adapter '%s' with "</span></span><br><span class="line">		       <span class="string">"no algo!\n"</span>, adap-&gt;name);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rt_mutex_init(&amp;adap-&gt;bus_lock);</span><br><span class="line">	mutex_init(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;adap-&gt;userspace_clients);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set default timeout to 1 second if not already set */</span></span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;timeout == <span class="number">0</span>)</span><br><span class="line">		adap-&gt;timeout = HZ;</span><br><span class="line"></span><br><span class="line">	dev_set_name(&amp;adap-&gt;dev, <span class="string">"i2c-%d"</span>, adap-&gt;nr);</span><br><span class="line">	adap-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class="line">	adap-&gt;dev.type = &amp;i2c_adapter_type;</span><br><span class="line">	res = device_register(&amp;adap-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out_list;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;adap-&gt;dev, <span class="string">"adapter [%s] registered\n"</span>, adap-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class="line">	res = class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class="line">				       adap-&gt;dev.parent);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		dev_warn(&amp;adap-&gt;dev,</span><br><span class="line">			 <span class="string">"Failed to create compatibility class link\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* bus recovery specific initialization */</span></span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;bus_recovery_info) &#123;</span><br><span class="line">		<span class="keyword">struct</span> i2c_bus_recovery_info *bri = adap-&gt;bus_recovery_info;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!bri-&gt;recover_bus) &#123;</span><br><span class="line">			dev_err(&amp;adap-&gt;dev, <span class="string">"No recover_bus() found, not using recovery\n"</span>);</span><br><span class="line">			adap-&gt;bus_recovery_info = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">goto</span> exit_recovery;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Generic GPIO recovery */</span></span><br><span class="line">		<span class="keyword">if</span> (bri-&gt;recover_bus == i2c_generic_gpio_recovery) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!gpio_is_valid(bri-&gt;scl_gpio)) &#123;</span><br><span class="line">				dev_err(&amp;adap-&gt;dev, <span class="string">"Invalid SCL gpio, not using recovery\n"</span>);</span><br><span class="line">				adap-&gt;bus_recovery_info = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="keyword">goto</span> exit_recovery;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (gpio_is_valid(bri-&gt;sda_gpio))</span><br><span class="line">				bri-&gt;get_sda = get_sda_gpio_value;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				bri-&gt;get_sda = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			bri-&gt;get_scl = get_scl_gpio_value;</span><br><span class="line">			bri-&gt;set_scl = set_scl_gpio_value;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bri-&gt;set_scl || !bri-&gt;get_scl) &#123;</span><br><span class="line">			<span class="comment">/* Generic SCL recovery */</span></span><br><span class="line">			dev_err(&amp;adap-&gt;dev, <span class="string">"No &#123;get|set&#125;_gpio() found, not using recovery\n"</span>);</span><br><span class="line">			adap-&gt;bus_recovery_info = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">exit_recovery:</span><br><span class="line">	<span class="comment">/* create pre-declared device nodes */</span></span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;nr &lt; __i2c_first_dynamic_bus_num)</span><br><span class="line">		i2c_scan_static_board_info(adap);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Notify drivers */</span></span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	bus_for_each_drv(&amp;i2c_bus_type, <span class="literal">NULL</span>, adap, __process_new_adapter);</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_list:</span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_register_adapter()注册i2c adapter，若注册成功则函数返回0，否则返回负的错误码</p>
<ul>
<li>检查i2c_adapter的name、algo成员的有效性，即i2c_adapter的name、algo必须存在定义</li>
<li>初始化i2c_adapter的bus_lock、userspace_clients_lock、userspace_clients等字段</li>
<li>初始化i2c_adapter对应的device，设置其name为“i2c-n”，n为dap-&gt;nr，其bus为i2c_bus_type，其device_type为i2c_adapter_type</li>
<li>调用device_register()向内核注册i2c_adapter的device，并在/sys/bus/i2c/devices/中创建相应的符号链接/sys/bus/i2c/devices/i2c-n/</li>
<li>若bus ID小于<strong>i2c_first_dynamic_bus_num的值，则调用i2c_scan_static_board_info()，为系统初始化阶段板级文件中静态定义的i2c board info创建对应的i2c_client结构体；</strong>i2c_first_dynamic_bus_num变量的值为所有静态注册的i2c board info所在的i2c bus number的最大值加1，因而若当前adapter的bus ID小于该变量，则说明该adapter下存在静态定义的i2c board info</li>
<li>调用bus_for_each_drv()，遍历i2c_bus_type下的所有device_driver，并对遍历的每个device_driver调用__process_new_adapter()</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">i2c_scan_static_board_info</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_devinfo	*devinfo;</span><br><span class="line"></span><br><span class="line">	down_read(&amp;__i2c_board_lock);</span><br><span class="line">	list_for_each_entry(devinfo, &amp;__i2c_board_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (devinfo-&gt;busnum == adapter-&gt;nr</span><br><span class="line">				&amp;&amp; !i2c_new_device(adapter,</span><br><span class="line">						&amp;devinfo-&gt;board_info))</span><br><span class="line">			dev_err(&amp;adapter-&gt;dev,</span><br><span class="line">				<span class="string">"Can't create device at 0x%02x\n"</span>,</span><br><span class="line">				devinfo-&gt;board_info.addr);</span><br><span class="line">	&#125;</span><br><span class="line">	up_read(&amp;__i2c_board_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_scan_static_board_info()遍历__i2c_board_list链表中在板级文件中静态定义的所有i2c board info，当该i2c board info描述的slave device的bus id等于该i2c_adapter的bus id，即slave device与adapter匹配成功时，调用i2c_new_device()在该i2c_adapter下为该slave device创建一个对应的i2c_client结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> __process_new_adapter(<span class="keyword">struct</span> device_driver *d, <span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> i2c_do_add_adapter(to_i2c_driver(d), data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当新注册i2c adapter时，需要遍历当前注册的所有i2c driver，对每个i2c driver调用i2c_do_add_adapter()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_do_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_driver *driver, <span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* Detect supported devices on that bus, and instantiate them */</span></span><br><span class="line">	i2c_detect(adap, driver);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Let legacy drivers scan this bus for matching devices */</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;attach_adapter) &#123;</span><br><span class="line">		dev_warn(&amp;adap-&gt;dev, <span class="string">"%s: attach_adapter method is deprecated\n"</span>,</span><br><span class="line">			 driver-&gt;driver.name);</span><br><span class="line">		dev_warn(&amp;adap-&gt;dev, <span class="string">"Please use another way to instantiate "</span></span><br><span class="line">			 <span class="string">"your i2c_client\n"</span>);</span><br><span class="line">		<span class="comment">/* We ignore the return code; if it fails, too bad */</span></span><br><span class="line">		driver-&gt;attach_adapter(adap);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实际调用i2c_detect()</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_detect</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter, <span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> *address_list;</span><br><span class="line">	<span class="keyword">struct</span> i2c_client *temp_client;</span><br><span class="line">	<span class="keyword">int</span> i, err = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> adap_id = i2c_adapter_id(adapter);</span><br><span class="line"></span><br><span class="line">	address_list = driver-&gt;address_list;</span><br><span class="line">	<span class="keyword">if</span> (!driver-&gt;detect || !address_list)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Stop here if the classes do not match */</span></span><br><span class="line">	<span class="keyword">if</span> (!(adapter-&gt;<span class="keyword">class</span> &amp; driver-&gt;<span class="keyword">class</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up a temporary client to help detect callback */</span></span><br><span class="line">	temp_client = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> i2c_client), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!temp_client)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	temp_client-&gt;adapter = adapter;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; address_list[i] != I2C_CLIENT_END; i += <span class="number">1</span>) &#123;</span><br><span class="line">		dev_dbg(&amp;adapter-&gt;dev, <span class="string">"found normal entry for adapter %d, "</span></span><br><span class="line">			<span class="string">"addr 0x%02x\n"</span>, adap_id, address_list[i]);</span><br><span class="line">		temp_client-&gt;addr = address_list[i];</span><br><span class="line">		err = i2c_detect_address(temp_client, driver);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(err))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kfree(temp_client);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_detect()自动探测该i2c adapter下插入的i2c设备</p>
<ul>
<li>若i2c driver的detect()回调函数不存在定义或i2c driver的address_list即支持的i2c地址列表为空，则函数直接返回0</li>
<li>若i2c adapter支持的class与i2c driver支持的class不同，则函数直接返回0</li>
<li>遍历i2c_driver支持的i2c地址列表，对遍历的每个i2c地址调用i2c_detect_address()</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_detect_address</span><span class="params">(<span class="keyword">struct</span> i2c_client *temp_client, </span><br><span class="line">                              <span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_board_info info;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *adapter = temp_client-&gt;adapter;</span><br><span class="line">	<span class="keyword">int</span> addr = temp_client-&gt;addr;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure the address is valid */</span></span><br><span class="line">	err = i2c_check_addr_validity(addr);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		dev_warn(&amp;adapter-&gt;dev, <span class="string">"Invalid probe address 0x%02x\n"</span>,</span><br><span class="line">			 addr);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Skip if already in use */</span></span><br><span class="line">	<span class="keyword">if</span> (i2c_check_addr_busy(adapter, addr))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure there is something at this address */</span></span><br><span class="line">	<span class="keyword">if</span> (!i2c_default_probe(adapter, addr))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Finally call the custom detection function */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> i2c_board_info));</span><br><span class="line">	info.addr = addr;</span><br><span class="line">	err = driver-&gt;detect(temp_client, &amp;info);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="comment">/* -ENODEV is returned if the detection fails. We catch it</span><br><span class="line">		   here as this isn't an error. */</span></span><br><span class="line">		<span class="keyword">return</span> err == -ENODEV ? <span class="number">0</span> : err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Consistency check */</span></span><br><span class="line">	<span class="keyword">if</span> (info.type[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">		dev_err(&amp;adapter-&gt;dev, <span class="string">"%s detection function provided "</span></span><br><span class="line">			<span class="string">"no name for 0x%x\n"</span>, driver-&gt;driver.name,</span><br><span class="line">			addr);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> i2c_client *client;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Detection succeeded, instantiate the device */</span></span><br><span class="line">		dev_dbg(&amp;adapter-&gt;dev, <span class="string">"Creating %s at 0x%02x\n"</span>,</span><br><span class="line">			info.type, info.addr);</span><br><span class="line">		client = i2c_new_device(adapter, &amp;info);</span><br><span class="line">		<span class="keyword">if</span> (client)</span><br><span class="line">			list_add_tail(&amp;client-&gt;detected, &amp;driver-&gt;clients);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			dev_err(&amp;adapter-&gt;dev, <span class="string">"Failed creating %s at 0x%02x\n"</span>,</span><br><span class="line">				info.type, info.addr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_detect_address()检查特定i2c地址处是否存在可用i2c client device</p>
<ul>
<li>调用i2c_check_addr_validity()检查传入的i2c地址的有效性，若该地址无效则函数直接返回0</li>
<li>调用i2c_check_addr_busy()检查该i2c地址处的设备是否正在被使用，若是则函数直接返回0</li>
<li>调用i2c_default_probe()由该i2c adapter向该i2c设备发送一个i2c message以检查该地址处是否存在一个已经插入的i2c设备</li>
<li>若该地址处存在一个插入的i2c设备，则调用i2c_driver的detect()回调函数获取该i2c设备的相关信息并存储在i2c_board_info结构中，之后调用i2c_new_device()为该设备分配对应的i2c_client结构，并将该i2c_client添加到i2c_driver的i2c_client设备链表中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_default_probe</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">unsigned</span> <span class="keyword">short</span> addr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data dummy;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line">	<span class="keyword">if</span> (addr == <span class="number">0x73</span> &amp;&amp; (adap-&gt;<span class="keyword">class</span> &amp; I2C_CLASS_HWMON)</span><br><span class="line">	 &amp;&amp; i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE_DATA))</span><br><span class="line">		err = i2c_smbus_xfer(adap, addr, <span class="number">0</span>, I2C_SMBUS_READ, <span class="number">0</span>,</span><br><span class="line">				     I2C_SMBUS_BYTE_DATA, &amp;dummy);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (!((addr &amp; ~<span class="number">0x07</span>) == <span class="number">0x30</span> || (addr &amp; ~<span class="number">0x0f</span>) == <span class="number">0x50</span>)</span><br><span class="line">	 &amp;&amp; i2c_check_functionality(adap, I2C_FUNC_SMBUS_QUICK))</span><br><span class="line">		err = i2c_smbus_xfer(adap, addr, <span class="number">0</span>, I2C_SMBUS_WRITE, <span class="number">0</span>,</span><br><span class="line">				     I2C_SMBUS_QUICK, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_BYTE))</span><br><span class="line">		err = i2c_smbus_xfer(adap, addr, <span class="number">0</span>, I2C_SMBUS_READ, <span class="number">0</span>,</span><br><span class="line">				     I2C_SMBUS_BYTE, &amp;dummy);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		dev_warn(&amp;adap-&gt;dev, <span class="string">"No suitable probing method supported\n"</span>);</span><br><span class="line">		err = -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_default_probe()由该i2c adapter向特定i2c地址处的i2c设备发送一个i2c message以检查该地址处是否存在一个已经插入的i2c设备</p>
<ul>
<li>若该i2c adapter支持I2C_FUNC_SMBUS_QUICK特性，则向该地址处发送一个quick message</li>
<li>而对于一些特殊的i2c地址，则需要向该地址处读一个字节的数据，即发送 read byte message</li>
<li>若发送的i2c message收到回应，则函数返回正值，否则函数返回-EOPNOTSUPP</li>
</ul>
<h5 id="i2c-del-adapter"><a href="#i2c-del-adapter" class="headerlink" title="i2c_del_adapter"></a>i2c_del_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_del_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *found;</span><br><span class="line">	<span class="keyword">struct</span> i2c_client *client, *next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* First make sure that this adapter was ever added */</span></span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	found = idr_find(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line">	<span class="keyword">if</span> (found != adap) &#123;</span><br><span class="line">		pr_debug(<span class="string">"i2c-core: attempting to delete unregistered "</span></span><br><span class="line">			 <span class="string">"adapter [%s]\n"</span>, adap-&gt;name);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Tell drivers about this removal */</span></span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	bus_for_each_drv(&amp;i2c_bus_type, <span class="literal">NULL</span>, adap,</span><br><span class="line">			       __process_removed_adapter);</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remove devices instantiated from sysfs */</span></span><br><span class="line">	mutex_lock_nested(&amp;adap-&gt;userspace_clients_lock,</span><br><span class="line">			  i2c_adapter_depth(adap));</span><br><span class="line">	list_for_each_entry_safe(client, next, &amp;adap-&gt;userspace_clients,</span><br><span class="line">				 detected) &#123;</span><br><span class="line">		dev_dbg(&amp;adap-&gt;dev, <span class="string">"Removing %s at 0x%x\n"</span>, client-&gt;name,</span><br><span class="line">			client-&gt;addr);</span><br><span class="line">		list_del(&amp;client-&gt;detected);</span><br><span class="line">		i2c_unregister_device(client);</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Detach any active clients. This can't fail, thus we do not</span><br><span class="line">	 * check the returned value. This is a two-pass process, because</span><br><span class="line">	 * we can't remove the dummy devices during the first pass: they</span><br><span class="line">	 * could have been instantiated by real devices wishing to clean</span><br><span class="line">	 * them up properly, so we give them a chance to do that first. */</span></span><br><span class="line">	device_for_each_child(&amp;adap-&gt;dev, <span class="literal">NULL</span>, __unregister_client);</span><br><span class="line">	device_for_each_child(&amp;adap-&gt;dev, <span class="literal">NULL</span>, __unregister_dummy);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_I2C_COMPAT</span></span><br><span class="line">	class_compat_remove_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,</span><br><span class="line">				 adap-&gt;dev.parent);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* device name is gone after device_unregister */</span></span><br><span class="line">	dev_dbg(&amp;adap-&gt;dev, <span class="string">"adapter [%s] unregistered\n"</span>, adap-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* clean up the sysfs representation */</span></span><br><span class="line">	init_completion(&amp;adap-&gt;dev_released);</span><br><span class="line">	device_unregister(&amp;adap-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* wait for sysfs to drop all references */</span></span><br><span class="line">	wait_for_completion(&amp;adap-&gt;dev_released);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* free bus id */</span></span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	idr_remove(&amp;i2c_adapter_idr, adap-&gt;nr);</span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Clear the device structure in case this adapter is ever going to be</span><br><span class="line">	   added again */</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;adap-&gt;dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(adap-&gt;dev));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_del_adapter()注销i2c adapter</p>
<h5 id="i2c-lock-adapter"><a href="#i2c-lock-adapter" class="headerlink" title="i2c_lock_adapter"></a>i2c_lock_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_lock_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (parent)</span><br><span class="line">		i2c_lock_adapter(parent);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rt_mutex_lock(&amp;adapter-&gt;bus_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_lock_adapter()获取该I2C bus的独占性访问（exclusive access），可能使进程进入睡眠状态</p>
<h5 id="i2c-trylock-adapter"><a href="#i2c-trylock-adapter" class="headerlink" title="i2c_trylock_adapter"></a>i2c_trylock_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_trylock_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (parent)</span><br><span class="line">		<span class="keyword">return</span> i2c_trylock_adapter(parent);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> rt_mutex_trylock(&amp;adapter-&gt;bus_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_trylock_adapter()尝试获取该I2C bus的独占性访问（exclusive access），当前获取独占性访问失败时函数立即返回，因而可以适用于interrupt context</p>
<h5 id="i2c-unlock-adapter"><a href="#i2c-unlock-adapter" class="headerlink" title="i2c_unlock_adapter"></a>i2c_unlock_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_unlock_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *parent = i2c_parent_is_i2c_adapter(adapter);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (parent)</span><br><span class="line">		i2c_unlock_adapter(parent);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rt_mutex_unlock(&amp;adapter-&gt;bus_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_unlock_adapter()释放该I2C bus的独占性访问（exclusive access）</p>
<h5 id="i2c-set-adapter-bus-clk-rate"><a href="#i2c-set-adapter-bus-clk-rate" class="headerlink" title="i2c_set_adapter_bus_clk_rate"></a>i2c_set_adapter_bus_clk_rate</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_set_adapter_bus_clk_rate</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">int</span> bus_rate)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	i2c_lock_adapter(adap);</span><br><span class="line">	adap-&gt;bus_clk_rate = bus_rate;</span><br><span class="line">	i2c_unlock_adapter(adap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_set_adapter_bus_clk_rate()设置该I2C bus的clock rate</p>
<h5 id="i2c-get-adapter-bus-clk-rate"><a href="#i2c-get-adapter-bus-clk-rate" class="headerlink" title="i2c_get_adapter_bus_clk_rate"></a>i2c_get_adapter_bus_clk_rate</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_get_adapter_bus_clk_rate</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> bus_clk_rate;</span><br><span class="line"></span><br><span class="line">	i2c_lock_adapter(adap);</span><br><span class="line">	bus_clk_rate = adap-&gt;bus_clk_rate;</span><br><span class="line">	i2c_unlock_adapter(adap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bus_clk_rate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_get_adapter_bus_clk_rate()返回该I2C bus的当前clock rate</p>
<h5 id="i2c-shutdown-adapter"><a href="#i2c-shutdown-adapter" class="headerlink" title="i2c_shutdown_adapter"></a>i2c_shutdown_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_shutdown_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	i2c_lock_adapter(adapter);</span><br><span class="line">	adapter-&gt;cancel_xfer_on_shutdown = <span class="literal">true</span>;</span><br><span class="line">	i2c_unlock_adapter(adapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_shutdown_adapter()表示当前adapter即将停止工作，通过设置cancel_xfer_on_shutdown标志位以通知i2c core接下来不要再受理i2c message的传输工作</p>
<h5 id="i2c-shutdown-clear-adapter"><a href="#i2c-shutdown-clear-adapter" class="headerlink" title="i2c_shutdown_clear_adapter"></a>i2c_shutdown_clear_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_shutdown_clear_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	i2c_lock_adapter(adapter);</span><br><span class="line">	adapter-&gt;cancel_xfer_on_shutdown = <span class="literal">false</span>;</span><br><span class="line">	adapter-&gt;atomic_xfer_only = <span class="literal">true</span>;</span><br><span class="line">	i2c_unlock_adapter(adapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_shutdown_clear_adapter()通过清除cancel_xfer_on_shutdown标志，同时设置atomic_xfer_only标志位，以恢复i2c message的传输</p>
<h5 id="i2c-get-adapdata"><a href="#i2c-get-adapdata" class="headerlink" title="i2c_get_adapdata"></a>i2c_get_adapdata</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">i2c_get_adapdata</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_adapter *dev)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dev_get_drvdata(&amp;dev-&gt;dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_get_adapdata()返回i2c adapter的driver data</p>
<h5 id="i2c-set-adapdata"><a href="#i2c-set-adapdata" class="headerlink" title="i2c_set_adapdata"></a>i2c_set_adapdata</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">i2c_set_adapdata</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *dev, <span class="keyword">void</span> *data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	dev_set_drvdata(&amp;dev-&gt;dev, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_set_adapdata()设置i2c adapter的driver data</p>
<h5 id="i2c-parent-is-i2c-adapter"><a href="#i2c-parent-is-i2c-adapter" class="headerlink" title="i2c_parent_is_i2c_adapter"></a>i2c_parent_is_i2c_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> i2c_adapter *</span><br><span class="line"><span class="title">i2c_parent_is_i2c_adapter</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> device *parent = adapter-&gt;dev.parent;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (parent != <span class="literal">NULL</span> &amp;&amp; parent-&gt;type == &amp;i2c_adapter_type)</span><br><span class="line">		<span class="keyword">return</span> to_i2c_adapter(parent);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_parent_is_i2c_adapter()检查当前i2c adapter的parent device是否对应于一个i2c adapter，若是则返回其parent device对应的i2c adapter，否则返回NULL</p>
<h5 id="i2c-get-adapter"><a href="#i2c-get-adapter" class="headerlink" title="i2c_get_adapter"></a>i2c_get_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> i2c_adapter *<span class="title">i2c_get_adapter</span><span class="params">(<span class="keyword">int</span> nr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *adapter;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;core_lock);</span><br><span class="line">	adapter = idr_find(&amp;i2c_adapter_idr, nr);</span><br><span class="line">	<span class="keyword">if</span> (adapter &amp;&amp; !try_module_get(adapter-&gt;owner))</span><br><span class="line">		adapter = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;core_lock);</span><br><span class="line">	<span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_get_adapter()根据bus number返回对应的i2c adapter，并增加该adapter对应的module的引用计数，若该bus number对应的i2c adapter不存在或增加module的引用计数失败，则返回NULL</p>
<h5 id="i2c-put-adapter"><a href="#i2c-put-adapter" class="headerlink" title="i2c_put_adapter"></a>i2c_put_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_put_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	module_put(adap-&gt;owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_put_adapter()减小该i2c adapter对应的module的引用计数</p>
<h5 id="i2c-clients-command"><a href="#i2c-clients-command" class="headerlink" title="i2c_clients_command"></a>i2c_clients_command</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_clients_command</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_cmd_arg	cmd_arg;</span><br><span class="line"></span><br><span class="line">	cmd_arg.cmd = cmd;</span><br><span class="line">	cmd_arg.arg = arg;</span><br><span class="line">	device_for_each_child(&amp;adap-&gt;dev, &amp;cmd_arg, i2c_cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_clients_command()遍历该i2c adapter下的所有i2c client，对其中的每个i2c client调用i2c_cmd()，实际调用该i2c cleint对应的device driver的command()回调函数以执行特定的动作，传入的cmd参数表示需要执行的命令，arg参数表示执行该命令的参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_cmd</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">void</span> *_arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_client	*client = i2c_verify_client(dev);</span><br><span class="line">	<span class="keyword">struct</span> i2c_cmd_arg	*arg = _arg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (client &amp;&amp; client-&gt;driver &amp;&amp; client-&gt;driver-&gt;command)</span><br><span class="line">		client-&gt;driver-&gt;command(client, arg-&gt;cmd, arg-&gt;arg);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="i2c-client-driver-API"><a href="#i2c-client-driver-API" class="headerlink" title="i2c client driver API"></a>i2c client driver API</h4><h5 id="i2c-new-device"><a href="#i2c-new-device" class="headerlink" title="i2c_new_device"></a>i2c_new_device</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> i2c_client *</span><br><span class="line"><span class="title">i2c_new_device</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_board_info <span class="keyword">const</span> *info)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_client	*client;</span><br><span class="line">	<span class="keyword">int</span>			status;</span><br><span class="line"></span><br><span class="line">	client = kzalloc(<span class="keyword">sizeof</span> *client, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	client-&gt;adapter = adap;</span><br><span class="line"></span><br><span class="line">	client-&gt;dev.platform_data = info-&gt;platform_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;archdata)</span><br><span class="line">		client-&gt;dev.archdata = *info-&gt;archdata;</span><br><span class="line"></span><br><span class="line">	client-&gt;flags = info-&gt;flags;</span><br><span class="line">	client-&gt;addr = info-&gt;addr;</span><br><span class="line">	client-&gt;irq = info-&gt;irq;</span><br><span class="line"></span><br><span class="line">	strlcpy(client-&gt;name, info-&gt;type, <span class="keyword">sizeof</span>(client-&gt;name));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for address validity */</span></span><br><span class="line">	status = i2c_check_client_addr_validity(client);</span><br><span class="line">	<span class="keyword">if</span> (status) &#123;</span><br><span class="line">		dev_err(&amp;adap-&gt;dev, <span class="string">"Invalid %d-bit I2C address 0x%02hx\n"</span>,</span><br><span class="line">			client-&gt;flags &amp; I2C_CLIENT_TEN ? <span class="number">10</span> : <span class="number">7</span>, client-&gt;addr);</span><br><span class="line">		<span class="keyword">goto</span> out_err_silent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check for address business */</span></span><br><span class="line">	status = i2c_check_addr_busy(adap, client-&gt;addr);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	client-&gt;dev.parent = &amp;client-&gt;adapter-&gt;dev;</span><br><span class="line">	client-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class="line">	client-&gt;dev.type = &amp;i2c_client_type;</span><br><span class="line">	client-&gt;dev.of_node = info-&gt;of_node;</span><br><span class="line">	ACPI_HANDLE_SET(&amp;client-&gt;dev, info-&gt;acpi_node.handle);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For 10-bit clients, add an arbitrary offset to avoid collisions */</span></span><br><span class="line">	dev_set_name(&amp;client-&gt;dev, <span class="string">"%d-%04x"</span>, i2c_adapter_id(adap),</span><br><span class="line">		     client-&gt;addr | ((client-&gt;flags &amp; I2C_CLIENT_TEN)</span><br><span class="line">				     ? <span class="number">0xa000</span> : <span class="number">0</span>));</span><br><span class="line">	status = device_register(&amp;client-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;adap-&gt;dev, <span class="string">"client [%s] registered with bus id %s\n"</span>,</span><br><span class="line">		client-&gt;name, dev_name(&amp;client-&gt;dev));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> client;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	dev_err(&amp;adap-&gt;dev, <span class="string">"Failed to register i2c client %s at 0x%02x "</span></span><br><span class="line">		<span class="string">"(%d)\n"</span>, client-&gt;name, client-&gt;addr, status);</span><br><span class="line">out_err_silent:</span><br><span class="line">	kfree(client);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_new_device()由i2c board info在i2c adapter下动态创建一个对应的i2c client</p>
<p>若成功函数返回创建的i2c client，否则函数返回NULL</p>
<p>@adap    管理该slave device的i2c_adapter<br>@info    描述该slave device信息的i2c_board_info结构，包括该slave device的i2c地址、platform data等信息</p>
<ul>
<li>动态分配一个i2c_client结构，并初始化该i2c_client，设置其adapter字段为传入的i2c_adapter，并根据传入的i2c_board_info设置i2c client的name、addr、irq、flags、dev.platform_data、dev.archdata等字段</li>
<li>调用i2c_check_client_addr_validity()检查该i2c地址是否有效</li>
<li>调用i2c_check_addr_busy()检查该i2c地址是否正在被使用</li>
<li>初始化该i2c_client的device字段，设置该device的parent字段为adap-&gt;dev，bus字段为i2c_bus_type，type字段为i2c_client_type，of_node字段为info-&gt;of_node，device的名称为 <code>bus_id - i2c_addr</code></li>
<li>调用device_register()向内核注册该i2c_client的device</li>
</ul>
<h5 id="i2c-new-probed-device"><a href="#i2c-new-probed-device" class="headerlink" title="i2c_new_probed_device"></a>i2c_new_probed_device</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_client *</span><br><span class="line">i2c_new_probed_device(struct i2c_adapter *adap,</span><br><span class="line">		      struct i2c_board_info *info,</span><br><span class="line">		      unsigned short const *addr_list,</span><br><span class="line">		      int (*probe)(struct i2c_adapter *, unsigned short addr))</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line"></span><br><span class="line">	if (!probe)</span><br><span class="line">		probe = i2c_default_probe;</span><br><span class="line"></span><br><span class="line">	for (i = 0; addr_list[i] != I2C_CLIENT_END; i++) &#123;</span><br><span class="line">		/* Check address validity */</span><br><span class="line">		if (i2c_check_addr_validity(addr_list[i]) &lt; 0) &#123;</span><br><span class="line">			dev_warn(&amp;adap-&gt;dev, "Invalid 7-bit address "</span><br><span class="line">				 "0x%02x\n", addr_list[i]);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* Check address availability */</span><br><span class="line">		if (i2c_check_addr_busy(adap, addr_list[i])) &#123;</span><br><span class="line">			dev_dbg(&amp;adap-&gt;dev, "Address 0x%02x already in "</span><br><span class="line">				"use, not probing\n", addr_list[i]);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/* Test address responsiveness */</span><br><span class="line">		if (probe(adap, addr_list[i]))</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (addr_list[i] == I2C_CLIENT_END) &#123;</span><br><span class="line">		dev_dbg(&amp;adap-&gt;dev, "Probing failed, no device found\n");</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	info-&gt;addr = addr_list[i];</span><br><span class="line">	return i2c_new_device(adap, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_new_probed_device()若不确定i2c client的i2c地址，而是只知道该i2c client的地址在传入的addr_list中，则由i2c core实现该i2c client的地址探测，并由i2c board info在i2c adapter下创建一个对应的i2c client</p>
<p>传入的probe()参数为地址探测时使用的回调函数，探测成功时该回调函数应该返回1，否则返回0；该参数可选，当该参数未定义时，使用i2c_default_probe()作为默认的探测函数</p>
<p>若成功函数返回创建的i2c client，否则函数返回NULL</p>
<p>@adap    管理该slave device的i2c_adapter<br>@info    描述该slave device信息的i2c_board_info结构，包括该slave device的i2c地址、platform data等信息<br>@addr_list  需要创建的i2c client的i2c地址范围<br>@probe  地址探测时需要调用的回调函数</p>
<ul>
<li>若传入的probe()参数为空，则使用i2c_default_probe()作为默认的探测函数</li>
<li>遍历传入的addr_list中的i2c address table，对于其中的每个i2c地址<ul>
<li>调用i2c_check_client_addr_validity()检查该i2c地址是否有效</li>
<li>调用i2c_check_addr_busy()检查该i2c地址是否正在被使用</li>
<li>调用probe()回调函数检测当前遍历的i2c地址是否为该i2c client的地址</li>
<li>若地址探测成功，则将该地址保存在传入的i2c board info的addr字段，之后调用i2c_new_device()注册该i2c client</li>
</ul>
</li>
</ul>
<h5 id="i2c-new-dummy"><a href="#i2c-new-dummy" class="headerlink" title="i2c_new_dummy"></a>i2c_new_dummy</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> i2c_client *<span class="title">i2c_new_dummy</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter, u16 address)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_board_info info = &#123;</span><br><span class="line">		I2C_BOARD_INFO(<span class="string">"dummy"</span>, address),</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i2c_new_device(adapter, &amp;info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若一个i2c设备支持多个i2c地址，则调用i2c_new_dummy()创建该i2c设备对应的i2c client</p>
<p>若成功函数返回创建的i2c client，否则函数返回NULL</p>
<h5 id="i2c-unregister-device"><a href="#i2c-unregister-device" class="headerlink" title="i2c_unregister_device"></a>i2c_unregister_device</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_unregister_device</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	device_unregister(&amp;client-&gt;dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_unregister_device()注销i2c client</p>
<h5 id="i2c-verify-client"><a href="#i2c-verify-client" class="headerlink" title="i2c_verify_client"></a>i2c_verify_client</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> i2c_client *<span class="title">i2c_verify_client</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (dev-&gt;type == &amp;i2c_client_type)</span><br><span class="line">			? to_i2c_client(dev)</span><br><span class="line">			: <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_verify_client()通常用于在device model iteration中检查当前遍历的device是否对应一个i2c client，若是则返回其对应的i2c client，否则返回NULL</p>
<h5 id="i2c-verify-adapter"><a href="#i2c-verify-adapter" class="headerlink" title="i2c_verify_adapter"></a>i2c_verify_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> i2c_adapter *<span class="title">i2c_verify_adapter</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (dev-&gt;type == &amp;i2c_adapter_type)</span><br><span class="line">			? to_i2c_adapter(dev)</span><br><span class="line">			: <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_verify_adapter()通常用于在device model iteration中检查当前遍历的device是否对应一个i2c adapter，若是则返回其对应的i2c client，否则返回NULL</p>
<h5 id="i2c-get-clientdata"><a href="#i2c-get-clientdata" class="headerlink" title="i2c_get_clientdata"></a>i2c_get_clientdata</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">i2c_get_clientdata</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *dev)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dev_get_drvdata(&amp;dev-&gt;dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_get_clientdata()返回i2c client的driver data</p>
<h5 id="i2c-set-clientdata"><a href="#i2c-set-clientdata" class="headerlink" title="i2c_set_clientdata"></a>i2c_set_clientdata</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">i2c_set_clientdata</span><span class="params">(<span class="keyword">struct</span> i2c_client *dev, <span class="keyword">void</span> *data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	dev_set_drvdata(&amp;dev-&gt;dev, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_set_clientdata()设置i2c client的driver data</p>
<h5 id="i2c-use-client"><a href="#i2c-use-client" class="headerlink" title="i2c_use_client"></a>i2c_use_client</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_client *i2c_use_client(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">	if (client &amp;&amp; get_device(&amp;client-&gt;dev))</span><br><span class="line">		return client;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_use_client()若该i2c client存在则增加其引用计数，并返回该i2c client，否则返回NULL</p>
<h5 id="i2c-release-client"><a href="#i2c-release-client" class="headerlink" title="i2c_release_client"></a>i2c_release_client</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_release_client</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (client)</span><br><span class="line">		put_device(&amp;client-&gt;dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_release_client()减小i2c client的引用计数</p>
<h5 id="i2c-register-driver"><a href="#i2c-register-driver" class="headerlink" title="i2c_register_driver"></a>i2c_register_driver</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_register_driver</span><span class="params">(<span class="keyword">struct</span> module *owner, <span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Can't register until after driver model init */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(WARN_ON(!i2c_bus_type.p)))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* add the driver to the list of i2c drivers in the driver core */</span></span><br><span class="line">	driver-&gt;driver.owner = owner;</span><br><span class="line">	driver-&gt;driver.bus = &amp;i2c_bus_type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* When registration returns, the driver core</span><br><span class="line">	 * will have called probe() for all matching-but-unbound devices.</span><br><span class="line">	 */</span></span><br><span class="line">	res = driver_register(&amp;driver-&gt;driver);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Drivers should switch to dev_pm_ops instead. */</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;suspend)</span><br><span class="line">		pr_warn(<span class="string">"i2c-core: driver [%s] using legacy suspend method\n"</span>,</span><br><span class="line">			driver-&gt;driver.name);</span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;resume)</span><br><span class="line">		pr_warn(<span class="string">"i2c-core: driver [%s] using legacy resume method\n"</span>,</span><br><span class="line">			driver-&gt;driver.name);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">"i2c-core: driver [%s] registered\n"</span>, driver-&gt;driver.name);</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;driver-&gt;clients);</span><br><span class="line">	<span class="comment">/* Walk the adapters that are already present */</span></span><br><span class="line">	i2c_for_each_dev(driver, __process_new_driver);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_register_driver()注册i2c_driver</p>
<p>@owner   注册到该模块<br>@driver  需要注册的i2c_driver</p>
<ul>
<li>设置该i2c_driver的device_driver的bus_type成员为i2c_bus_type</li>
<li>调用driver_register()注册该i2c_driver的device_driver</li>
<li>初始化该i2c_driver的i2c_client设备链表</li>
<li>调用i2c_for_each_dev()与__process_new_driver()，遍历当前已经注册的i2c adapter，对于其中的每个i2c adapter调用i2c_do_add_adapter()</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __process_new_driver(<span class="keyword">struct</span> device *dev, <span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;type != &amp;i2c_adapter_type)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> i2c_do_add_adapter(data, to_i2c_adapter(dev));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__process_new_driver()遍历当前注册的所有i2c adapter，对其中的每个i2c adapter调用i2c_do_add_adapter()</p>
<h5 id="i2c-add-driver"><a href="#i2c-add-driver" class="headerlink" title="i2c_add_driver"></a>i2c_add_driver</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> i2c_add_driver(driver) \</span><br><span class="line">	i2c_register_driver(THIS_MODULE, driver)</span></span><br></pre></td></tr></table></figure>
<p>i2c_add_driver()注册i2c_driver，实际调用i2c_register_driver()</p>
<h5 id="i2c-del-driver"><a href="#i2c-del-driver" class="headerlink" title="i2c_del_driver"></a>i2c_del_driver</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_del_driver</span><span class="params">(<span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	i2c_for_each_dev(driver, __process_removed_driver);</span><br><span class="line"></span><br><span class="line">	driver_unregister(&amp;driver-&gt;driver);</span><br><span class="line">	pr_debug(<span class="string">"i2c-core: driver [%s] unregistered\n"</span>, driver-&gt;driver.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_del_driver()注销i2c driver</p>
<ul>
<li>通过调用__process_removed_driver()遍历当前注册的所有i2c adapter，对于其中的每个i2c adapter调用i2c_do_del_adapter()，其中注销该i2c driver支持的所有i2c client</li>
<li>调用driver_unregister()注销该i2c driver对应的device driver</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __process_removed_driver(<span class="keyword">struct</span> device *dev, <span class="keyword">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;type == &amp;i2c_adapter_type)</span><br><span class="line">		i2c_do_del_adapter(data, to_i2c_adapter(dev));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">i2c_do_del_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_driver *driver,</span><br><span class="line">			      <span class="keyword">struct</span> i2c_adapter *adapter)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_client *client, *_n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remove the devices we created ourselves as the result of hardware</span><br><span class="line">	 * probing (using a driver's detect method) */</span></span><br><span class="line">	list_for_each_entry_safe(client, _n, &amp;driver-&gt;clients, detected) &#123;</span><br><span class="line">		<span class="keyword">if</span> (client-&gt;adapter == adapter) &#123;</span><br><span class="line">			dev_dbg(&amp;adapter-&gt;dev, <span class="string">"Removing %s at 0x%x\n"</span>,</span><br><span class="line">				client-&gt;name, client-&gt;addr);</span><br><span class="line">			list_del(&amp;client-&gt;detected);</span><br><span class="line">			i2c_unregister_device(client);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="i2c-board-info-operations"><a href="#i2c-board-info-operations" class="headerlink" title="i2c board info operations"></a>i2c board info operations</h4><p>CONFIG_I2C_BOARDINFO配置项用于配置i2c board info support，即在i2c adapter初始化之前，系统初始化过程中可以调用i2c_register_board_info()向i2c core静态注册i2c board info table，之后当i2c adapter初始化过程中，i2c core会根据注册的i2c board info创建相应的i2c client</p>
<p><code>drivers/i2c/i2c-boardinfo.c</code>中定义i2c board info support</p>
<h5 id="i2c-board-list-链表"><a href="#i2c-board-list-链表" class="headerlink" title="__i2c_board_list 链表"></a>__i2c_board_list 链表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIST_HEAD(__i2c_board_list);</span><br></pre></td></tr></table></figure>
<p>__i2c_board_list 全局链表用于管理所有注册的i2c board info (devinfo)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __i2c_first_dynamic_bus_num;</span><br></pre></td></tr></table></figure>
<p>__i2c_first_dynamic_bus_num 变量的值为通过i2c_register_board_info()注册的所有i2c board info所在的i2c bus number的最大值加1</p>
<h5 id="I2C-BOARD-INFO"><a href="#I2C-BOARD-INFO" class="headerlink" title="I2C_BOARD_INFO"></a>I2C_BOARD_INFO</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_BOARD_INFO(dev_type, dev_addr) \</span><br><span class="line">	.type = dev_type, .addr = (dev_addr)</span></span><br></pre></td></tr></table></figure>
<p>I2C_BOARD_INFO()宏静态初始化i2c_board_info</p>
<h5 id="i2c-register-board-info"><a href="#i2c-register-board-info" class="headerlink" title="i2c_register_board_info"></a>i2c_register_board_info</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">init <span class="title">i2c_register_board_info</span><span class="params">(<span class="keyword">int</span> busnum, <span class="keyword">struct</span> i2c_board_info <span class="keyword">const</span> *info,                                   </span><br><span class="line">                                   <span class="keyword">unsigned</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">	down_write(&amp;__i2c_board_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* dynamic bus numbers will be assigned after the last static one */</span></span><br><span class="line">	<span class="keyword">if</span> (busnum &gt;= __i2c_first_dynamic_bus_num)</span><br><span class="line">		__i2c_first_dynamic_bus_num = busnum + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (status = <span class="number">0</span>; len; len--, info++) &#123;</span><br><span class="line">		<span class="keyword">struct</span> i2c_devinfo	*devinfo;</span><br><span class="line"></span><br><span class="line">		devinfo = kzalloc(<span class="keyword">sizeof</span>(*devinfo), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!devinfo) &#123;</span><br><span class="line">			pr_debug(<span class="string">"i2c-core: can't register boardinfo!\n"</span>);</span><br><span class="line">			status = -ENOMEM;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		devinfo-&gt;busnum = busnum;</span><br><span class="line">		devinfo-&gt;board_info = *info;</span><br><span class="line">		list_add_tail(&amp;devinfo-&gt;<span class="built_in">list</span>, &amp;__i2c_board_list);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	up_write(&amp;__i2c_board_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_register_board_info()通常用于在板级文件中静态注册i2c board info</p>
<p>函数返回成功注册的i2c board info的数量，失败返回-ENOMEM</p>
<p>@busnum  注册的i2c board info所在的i2c bus的bus number<br>@info    需要注册的i2c_board_info数组<br>@len     需要注册的i2c_board_info数组的长度</p>
<ul>
<li>遍历传入的i2c board info table，为其中的每个i2c_board_info分配一个i2c_devinfo结构体，并将创建的i2c_devinfo添加到__i2c_board_list全局链表中</li>
</ul>
<h4 id="standard-I2C-protocol-data-transfer"><a href="#standard-I2C-protocol-data-transfer" class="headerlink" title="standard I2C protocol data transfer"></a>standard I2C protocol data transfer</h4><p>standard I2C 数据传输的单位为 i2c_msg，一个i2c message可以包含多个字节的数据</p>
<p>可以通过i2c_master_send()或i2c_master_recv()接口进行简单的i2c数据传输，每次只传输一个i2c_msg</p>
<p>同时也可以通过 i2c_transfer()接口进行复杂的i2c数据传输，每次可以传输一个或多个i2c_msg，一次传输过程中的不同i2c message可以指向多个不同的目标slave device的i2c地址</p>
<h5 id="i2c-master-send-1"><a href="#i2c-master-send-1" class="headerlink" title="i2c_master_send"></a>i2c_master_send</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_master_send</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *adap = client-&gt;adapter;</span><br><span class="line">	<span class="keyword">struct</span> i2c_msg msg;</span><br><span class="line"></span><br><span class="line">	msg.addr = client-&gt;addr;</span><br><span class="line">	msg.flags = client-&gt;flags &amp; I2C_M_TEN;</span><br><span class="line">	msg.len = count;</span><br><span class="line">	msg.buf = (<span class="keyword">char</span> *)buf;</span><br><span class="line"></span><br><span class="line">	ret = i2c_transfer(adap, &amp;msg, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * If everything went ok (i.e. 1 msg transmitted), return #bytes</span><br><span class="line">	 * transmitted, else error code.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">return</span> (ret == <span class="number">1</span>) ? count : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_master_send()向目标i2c_client传输一个i2c_msg数据</p>
<p>@client  数据传输的目标slave device<br>@buf     该buf保存需要发送的数据<br>@count   发送的数据的长度，以byte为单位，由于msg.len为u16，因而传输的数据必须小于64K byte</p>
<p>返回成功传输的数据的字节数，否则返回负的错误码</p>
<ul>
<li>分配并初始化一个i2c_msg，其中i2c_msg的addr即为i2c_client的addr，i2c_msg的len即为传入的参数count，i2c_msg的buf即为传入的参数buf，若i2c_client的flags包含I2C_M_TEN，则i2c_msg的flags即为I2C_M_TEN，否则i2c_msg的flags为0</li>
<li>调用i2c_transfer()在该i2c_client对应的i2c_adapter上传输上述构造的i2c_msg</li>
</ul>
<h5 id="i2c-master-recv-1"><a href="#i2c-master-recv-1" class="headerlink" title="i2c_master_recv"></a>i2c_master_recv</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_master_recv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client, <span class="keyword">char</span> *buf, <span class="keyword">int</span> count)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *adap = client-&gt;adapter;</span><br><span class="line">	<span class="keyword">struct</span> i2c_msg msg;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	msg.addr = client-&gt;addr;</span><br><span class="line">	msg.flags = client-&gt;flags &amp; I2C_M_TEN;</span><br><span class="line">	msg.flags |= I2C_M_RD;</span><br><span class="line">	msg.len = count;</span><br><span class="line">	msg.buf = buf;</span><br><span class="line"></span><br><span class="line">	ret = i2c_transfer(adap, &amp;msg, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * If everything went ok (i.e. 1 msg received), return #bytes received,</span><br><span class="line">	 * else error code.</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">return</span> (ret == <span class="number">1</span>) ? count : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_master_recv  接收目标i2c_client传输的一个i2c_msg数据</p>
<p>@client  数据传输的目标slave device<br>@buf     该buf保存需要发送的数据<br>@count   需要读取数据的长度，以byte为单位，由于msg.len为u16，因而传输的数据必须小于64K byte</p>
<p>返回成功传输的数据的字节数，否则返回负的错误码</p>
<ul>
<li>分配并初始化一个i2c_msg，其中i2c_msg的addr即为i2c_client的地址addr，i2c_msg的len即为传入的参数count，i2c_msg的buf即为传入的参数buf，若i2c_client的flags包含I2C_M_TEN，则i2c_msg的flags即为I2C_M_TEN | I2C_M_RD，否则i2c_msg的flags为I2C_M_RD</li>
<li>调用i2c_transfer()在该i2c_client对应的i2c_adapter上传输上述构造的i2c_msg</li>
</ul>
<h5 id="i2c-transfer-1"><a href="#i2c-transfer-1" class="headerlink" title="i2c_transfer"></a>i2c_transfer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_transfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs, <span class="keyword">int</span> num)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* REVISIT the fault reporting model here is weak:</span><br><span class="line">	 *</span><br><span class="line">	 *  - When we get an error after receiving N bytes from a slave,</span><br><span class="line">	 *    there is no way to report "N".</span><br><span class="line">	 *</span><br><span class="line">	 *  - When we get a NAK after transmitting N bytes to a slave,</span><br><span class="line">	 *    there is no way to report "N" ... or to let the master</span><br><span class="line">	 *    continue executing the rest of this combined message, if</span><br><span class="line">	 *    that's the appropriate response.</span><br><span class="line">	 *</span><br><span class="line">	 *  - When for example "num" is two and we successfully complete</span><br><span class="line">	 *    the first message but get an error part way through the</span><br><span class="line">	 *    second, it's unclear whether that should be reported as</span><br><span class="line">	 *    one (discarding status on the second message) or errno</span><br><span class="line">	 *    (discarding status on the first one).</span><br><span class="line">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;algo-&gt;master_xfer) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">		<span class="keyword">for</span> (ret = <span class="number">0</span>; ret &lt; num; ret++) &#123;</span><br><span class="line">			dev_dbg(&amp;adap-&gt;dev, <span class="string">"master_xfer[%d] %c, addr=0x%02x, "</span></span><br><span class="line">				<span class="string">"len=%d%s\n"</span>, ret, (msgs[ret].flags &amp; I2C_M_RD)</span><br><span class="line">				? <span class="string">'R'</span> : <span class="string">'W'</span>, msgs[ret].addr, msgs[ret].len,</span><br><span class="line">				(msgs[ret].flags &amp; I2C_M_RECV_LEN) ? <span class="string">"+"</span> : <span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (in_atomic() || irqs_disabled()) &#123;</span><br><span class="line">			ret = i2c_trylock_adapter(adap);</span><br><span class="line">			<span class="keyword">if</span> (!ret)</span><br><span class="line">				<span class="comment">/* I2C activity is ongoing. */</span></span><br><span class="line">				<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			i2c_lock_adapter(adap);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!adap-&gt;cancel_xfer_on_shutdown)</span><br><span class="line">			ret = __i2c_transfer(adap, msgs, num);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			WARN_ON(<span class="number">1</span>);</span><br><span class="line">			ret = -EPERM;</span><br><span class="line">		&#125;</span><br><span class="line">		i2c_unlock_adapter(adap);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dev_dbg(&amp;adap-&gt;dev, <span class="string">"I2C level transfers not supported\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_transfer()执行标准I2C的数据传输，在特定i2c_adapter上传输一个或多个i2c_msg数据</p>
<p>@adap    由该i2c adapter传输数据<br>@msgs    需要传输的一个或多个i2c_msg<br>@num     传输的i2c_msg的数量</p>
<p>返回成功传输的i2c message的个数，否则返回负的错误码</p>
<ul>
<li>若adapter的algorithm的master_xfer()回调函数存在定义，则执行以下操作，否则函数直接返回-EOPNOTSUPP</li>
<li>若当前处于IRQ disabled即interrupt  context，则调用i2c_trylock_adapter()尝试获取I2C bus的独占性访问，否则调用i2c_lock_adapter()获取I2C bus的独占性访问</li>
<li>若当前cancel_xfer_on_shutdown标志位未设置，即当前可以进行i2c message的传输，则调用<strong>i2c_transfer()函数，</strong>i2c_transfer函数调用i2c_adapter的i2c_algorithm的master_xfer()回调函数对传入的i2c_msg进行传输；否则若cancel_xfer_on_shutdown标志位被设置，说明adapter即将停止工作，此时函数返回-EPERM</li>
<li>调用i2c_unlock_adapter()释放该I2C bus的独占性访问</li>
</ul>
<h5 id="i2c-transfer-2"><a href="#i2c-transfer-2" class="headerlink" title="__i2c_transfer"></a>__i2c_transfer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __i2c_transfer(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs, <span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> orig_jiffies;</span><br><span class="line">	<span class="keyword">int</span> ret, <span class="keyword">try</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Retry automatically on arbitration loss */</span></span><br><span class="line">	orig_jiffies = jiffies;</span><br><span class="line">	<span class="keyword">for</span> (ret = <span class="number">0</span>, <span class="keyword">try</span> = <span class="number">0</span>; <span class="keyword">try</span> &lt;= adap-&gt;retries; <span class="keyword">try</span>++) &#123;</span><br><span class="line">		ret = adap-&gt;algo-&gt;master_xfer(adap, msgs, num);</span><br><span class="line">		<span class="keyword">if</span> (ret != -EAGAIN)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (time_after(jiffies, orig_jiffies + adap-&gt;timeout))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当已经获得I2C bus的独占性访问，即已经获得bus clock时，可以调用__i2c_transfer()执行i2c message的传输工作，由特定adapter传输num数量的i2c message</p>
<p>函数返回成功传输的i2c message的数量，否则返回负的错误码</p>
<ul>
<li>实际调用该adapter的algorithm的master_xfer()回调函数执行标准I2C的数据传输</li>
<li>若master_xfer()回调函数返回-EAGAIN，则再次调用master_xfer()回调函数尝试再次传输，当传输过程超过adapter的timeout指定的超时时间，或重试次数超过adapter的retries指定的重试次数时，此时数据传输失败，函数返回相应的错误码</li>
</ul>
<h4 id="SMBus-protocol-data-transfer"><a href="#SMBus-protocol-data-transfer" class="headerlink" title="SMBus protocol data transfer"></a>SMBus protocol data transfer</h4><p>SMBus protocol 数据传输的单位为 i2c_smbus_data，一个i2c_smbus_data可以是一个字节byte，或一个字word（即2 bytes），也可以是一个数据块block（max 32 bytes）</p>
<p>可以通过i2c_smbus_xfer()接口传输一个i2c_smbus_data</p>
<p>同时也可以通过其他一系列的variant interface，这些variant interface实际是i2c_smbus_xfer()的封装，执行data size specific的数据传输</p>
<h5 id="i2c-smbus-xfer"><a href="#i2c-smbus-xfer" class="headerlink" title="i2c_smbus_xfer"></a>i2c_smbus_xfer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">s32 <span class="title">i2c_smbus_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter, u16 addr, <span class="keyword">unsigned</span> <span class="keyword">short</span> flags,</span><br><span class="line">		   <span class="keyword">char</span> read_write, u8 command, <span class="keyword">int</span> protocol, <span class="keyword">union</span> i2c_smbus_data *data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> orig_jiffies;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">try</span>;</span><br><span class="line">	s32 res;</span><br><span class="line"></span><br><span class="line">	flags &amp;= I2C_M_TEN | I2C_CLIENT_PEC | I2C_CLIENT_SCCB;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (adapter-&gt;algo-&gt;smbus_xfer) &#123;</span><br><span class="line">		i2c_lock_adapter(adapter);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Retry automatically on arbitration loss */</span></span><br><span class="line">		orig_jiffies = jiffies;</span><br><span class="line">		<span class="keyword">for</span> (res = <span class="number">0</span>, <span class="keyword">try</span> = <span class="number">0</span>; <span class="keyword">try</span> &lt;= adapter-&gt;retries; <span class="keyword">try</span>++) &#123;</span><br><span class="line">			res = adapter-&gt;algo-&gt;smbus_xfer(adapter, addr, flags,</span><br><span class="line">							read_write, command,</span><br><span class="line">							protocol, data);</span><br><span class="line">			<span class="keyword">if</span> (res != -EAGAIN)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span> (time_after(jiffies,</span><br><span class="line">				       orig_jiffies + adapter-&gt;timeout))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		i2c_unlock_adapter(adapter);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (res != -EOPNOTSUPP || !adapter-&gt;algo-&gt;master_xfer)</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * Fall back to i2c_smbus_xfer_emulated if the adapter doesn't</span><br><span class="line">		 * implement native support for the SMBus operation.</span><br><span class="line">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_xfer_emulated(adapter, addr, flags, read_write,</span><br><span class="line">				       command, protocol, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_xfer()执行SMBus protocol的数据传输</p>
<p>@adapter     需要传输数据的 smbus<br>@addr        数据传输的目标slave device的i2c地址<br>@flags       数据传输的标志，I2C<em>CLIENT</em>*标志集<br>@read_write  数据发送或接收的标志位，I2C_SMBUS_READ or I2C_SMBUS_WRITE<br>@command     Byte interpreted by slave，通常表示slave device需要读取或写入的寄存器地址<br>@protocol    描述需要执行的SMBus protocol operation的类型，如I2C_SMBUS_BYTE_DATA等，通常表示传输的数据的大小<br>@data        需要传输的数据，SMBus protocol数据传输以i2c_smbus_data为单位</p>
<p>成功返回0，否则返回负的错误码</p>
<p>flags标志位描述slave device的特性，只支持I2C_M_TEN、I2C_CLIENT_PEC、I2C_CLIENT_SCCB标志</p>
<p>I2C_M_TEN 描述slave device使用10 bit i2c address<br>I2C_CLIENT_PEC 描述slave device支持 SMBus Packet Error Checking</p>
<p>read_write标志位描述数据传输的方向</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_SMBUS_READ  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_SMBUS_WRITE 0</span></span><br></pre></td></tr></table></figure>
<p>I2C_SMBUS_READ 描述数据传输的方向为 slave -&gt; master<br>I2C_SMBUS_WRITE 描述数据传输的方向为 master -&gt; slave</p>
<p>protocol标志位描述SMBus protocol数据传输的类型，通常表示传输的数据的大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_SMBUS_QUICK		    0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_SMBUS_BYTE		       1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_SMBUS_BYTE_DATA	    2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_SMBUS_WORD_DATA	    3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_SMBUS_PROC_CALL	    4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_SMBUS_BLOCK_DATA	    5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_SMBUS_I2C_BLOCK_BROKEN  6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_SMBUS_BLOCK_PROC_CALL   7 <span class="comment">/* SMBus 2.0 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_SMBUS_I2C_BLOCK_DATA    8</span></span><br></pre></td></tr></table></figure>
<ul>
<li>传入的flags标志位只支持I2C_M_TEN、I2C_CLIENT_PEC、I2C_CLIENT_SCCB标志</li>
<li>若i2c_adapter的i2c_algorithm的smbus_xfer()回调函数存在定义，则调用smbus_xfer()函数进行SMBus protocol数据传输<ul>
<li>调用i2c_lock_adapter()获取该SMBus的独占性访问</li>
<li>调用smbus_xfer()回调函数进行SMBus protocol数据传输</li>
<li>若smbus_xfer()回调函数返回-EAGAIN，则再次调用smbus_xfer()回调函数尝试再次传输，当传输过程超过adapter的timeout指定的超时时间，或重试次数超过adapter的retries指定的重试次数时，此时数据传输失败，不再尝试重发</li>
<li>调用i2c_unlock_adapter()释放该I2C bus的独占性访问</li>
<li>若smbus_xfer()回调函数返回-EOPNOTSUPP，同时该adapter的master_xfer()回调函数存在定义，则调用i2c_smbus_xfer_emulated()尝试使用standard I2C protocol模拟SMBus protocol进行数据传输，否则函数返回相应的错误码</li>
</ul>
</li>
<li>否则调用i2c_smbus_xfer_emulated()函数进行数据传输，其中使用standard I2C protocol模拟SMBus protocol进行数据传输</li>
</ul>
<h5 id="i2c-probe-func-quick-read"><a href="#i2c-probe-func-quick-read" class="headerlink" title="i2c_probe_func_quick_read"></a>i2c_probe_func_quick_read</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_probe_func_quick_read</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">unsigned</span> <span class="keyword">short</span> addr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_xfer(adap, addr, <span class="number">0</span>, I2C_SMBUS_READ, <span class="number">0</span>,</span><br><span class="line">			      I2C_SMBUS_QUICK, <span class="literal">NULL</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_probe_func_quick_read()使用smbus协议通过向特定i2c地址处发送一个SMBUS_QUICK message，以检测该地址处是否存在一个i2c设备</p>
<h5 id="i2c-smbus-read-byte"><a href="#i2c-smbus-read-byte" class="headerlink" title="i2c_smbus_read_byte"></a>i2c_smbus_read_byte</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">s32 <span class="title">i2c_smbus_read_byte</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">	status = i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">				I2C_SMBUS_READ, <span class="number">0</span>,</span><br><span class="line">				I2C_SMBUS_BYTE, &amp;data);</span><br><span class="line">	<span class="keyword">return</span> (status &lt; <span class="number">0</span>) ? status : data.byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_read_byte()使用smbus协议从slave device读取一个字节的数据</p>
<p>成功返回读取的一个字节的数据，否则返回负的错误码</p>
<h5 id="i2c-smbus-write-byte"><a href="#i2c-smbus-write-byte" class="headerlink" title="i2c_smbus_write_byte"></a>i2c_smbus_write_byte</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">s32 <span class="title">i2c_smbus_write_byte</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client, u8 value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">	                      I2C_SMBUS_WRITE, value, I2C_SMBUS_BYTE, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_write_byte()使用smbus协议向slave device发送一个字节的数据</p>
<p>成功返回0，否则返回负的错误码</p>
<h5 id="i2c-smbus-read-byte-data"><a href="#i2c-smbus-read-byte-data" class="headerlink" title="i2c_smbus_read_byte_data"></a>i2c_smbus_read_byte_data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">s32 <span class="title">i2c_smbus_read_byte_data</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client, u8 command)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">	status = i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">				I2C_SMBUS_READ, command,</span><br><span class="line">				I2C_SMBUS_BYTE_DATA, &amp;data);</span><br><span class="line">	<span class="keyword">return</span> (status &lt; <span class="number">0</span>) ? status : data.byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_read_byte_data()使用smbus协议读取slave device的特定寄存器的一个字节的数据，command参数描述读取的寄存器的地址</p>
<p>成功返回读取的一个字节的数据，否则返回负的错误码</p>
<h5 id="i2c-smbus-write-byte-data"><a href="#i2c-smbus-write-byte-data" class="headerlink" title="i2c_smbus_write_byte_data"></a>i2c_smbus_write_byte_data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">s32 <span class="title">i2c_smbus_write_byte_data</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client, u8 command,</span><br><span class="line">                                u8 value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	data.byte = value;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">			      I2C_SMBUS_WRITE, command,</span><br><span class="line">			      I2C_SMBUS_BYTE_DATA, &amp;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_write_byte_data()使用smbus协议向slave device的特定寄存器写入一个字节的数据，command参数描述写入的寄存器的地址</p>
<p>成功返回0，否则返回负的错误码</p>
<h5 id="i2c-smbus-read-word-data"><a href="#i2c-smbus-read-word-data" class="headerlink" title="i2c_smbus_read_word_data"></a>i2c_smbus_read_word_data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">s32 <span class="title">i2c_smbus_read_word_data</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client, u8 command)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">	status = i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">				I2C_SMBUS_READ, command,</span><br><span class="line">				I2C_SMBUS_WORD_DATA, &amp;data);</span><br><span class="line">	<span class="keyword">return</span> (status &lt; <span class="number">0</span>) ? status : data.word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_read_word_data()使用smbus协议读取slave device的特定寄存器的一个字（word，16 bit）的数据，command参数描述读取的寄存器的地址</p>
<p>成功返回读取的一个字的数据，否则返回负的错误码</p>
<h5 id="i2c-smbus-write-word-data"><a href="#i2c-smbus-write-word-data" class="headerlink" title="i2c_smbus_write_word_data"></a>i2c_smbus_write_word_data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">s32 <span class="title">i2c_smbus_write_word_data</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client, u8 command,</span><br><span class="line">			                         u16 value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	data.word = value;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">			      I2C_SMBUS_WRITE, command,</span><br><span class="line">			      I2C_SMBUS_WORD_DATA, &amp;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_write_word_data()使用smbus协议向slave device的特定寄存器写入一个字（word，16 bit）的数据，command参数描述写入的寄存器的地址</p>
<p>成功返回0，否则返回负的错误码</p>
<h5 id="i2c-smbus-read-word-swapped"><a href="#i2c-smbus-read-word-swapped" class="headerlink" title="i2c_smbus_read_word_swapped"></a>i2c_smbus_read_word_swapped</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> s32</span><br><span class="line"><span class="title">i2c_smbus_read_word_swapped</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client, u8 command)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	s32 value = i2c_smbus_read_word_data(client, command);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (value &lt; <span class="number">0</span>) ? value : swab16(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_read_word_swapped()与i2c_smbus_read_word_data()相类似，只是将读取的一个字（16 bit, 2 bytes）的数据转换字节序之后再返回读取的一个字的数据，即若读取的数据为0x00ff，则返回的数据为0xff00</p>
<h5 id="i2c-smbus-write-word-swapped"><a href="#i2c-smbus-write-word-swapped" class="headerlink" title="i2c_smbus_write_word_swapped"></a>i2c_smbus_write_word_swapped</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> s32</span><br><span class="line"><span class="title">i2c_smbus_write_word_swapped</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client,</span><br><span class="line">			     u8 command, u16 value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_write_word_data(client, command, swab16(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_write_word_swapped()与i2c_smbus_write_word_data()相类似，只是将传入的需要写入的一个字（16 bit, 2 bytes）的数据转换字节序之后再将其写入相应的寄存器中，即若需要写入的数据为0x00ff，则实际写入的数据为0xff00</p>
<h5 id="i2c-smbus-read-block-data"><a href="#i2c-smbus-read-block-data" class="headerlink" title="i2c_smbus_read_block_data"></a>i2c_smbus_read_block_data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">s32 <span class="title">i2c_smbus_read_block_data</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client, u8 command,</span><br><span class="line">			                         u8 *values)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">	status = i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">				I2C_SMBUS_READ, command,</span><br><span class="line">				I2C_SMBUS_BLOCK_DATA, &amp;data);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(values, &amp;data.block[<span class="number">1</span>], data.block[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> data.block[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_read_block_data()使用smbus协议从slave device的特定寄存器读取一块数据（最多32 bytes），command参数描述读取的寄存器的地址，values指针用于保存读取的数据</p>
<p>返回成功读取的数据的字节数，否则返回负的错误码</p>
<h5 id="i2c-smbus-write-block-data"><a href="#i2c-smbus-write-block-data" class="headerlink" title="i2c_smbus_write_block_data"></a>i2c_smbus_write_block_data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">s32 <span class="title">i2c_smbus_write_block_data</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client, u8 command,</span><br><span class="line">			                         u8 length, <span class="keyword">const</span> u8 *values)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (length &gt; I2C_SMBUS_BLOCK_MAX)</span><br><span class="line">		length = I2C_SMBUS_BLOCK_MAX;</span><br><span class="line">	data.block[<span class="number">0</span>] = length;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;data.block[<span class="number">1</span>], values, length);</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">			      I2C_SMBUS_WRITE, command,</span><br><span class="line">			      I2C_SMBUS_BLOCK_DATA, &amp;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_write_block_data()使用smbus协议向slave device的特定寄存器写入一块数据（最多32 bytes），command参数描述写入的寄存器的地址，values指针保存需要写入的数据，length参数为需要写入的数据的字节数</p>
<p>成功返回0，否则返回负的错误码</p>
<h5 id="i2c-smbus-read-i2c-block-data"><a href="#i2c-smbus-read-i2c-block-data" class="headerlink" title="i2c_smbus_read_i2c_block_data"></a>i2c_smbus_read_i2c_block_data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">s32 <span class="title">i2c_smbus_read_i2c_block_data</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client, u8 command,</span><br><span class="line">				  u8 length, u8 *values)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (length &gt; I2C_SMBUS_BLOCK_MAX)</span><br><span class="line">		length = I2C_SMBUS_BLOCK_MAX;</span><br><span class="line">	data.block[<span class="number">0</span>] = length;</span><br><span class="line">	status = i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">				I2C_SMBUS_READ, command,</span><br><span class="line">				I2C_SMBUS_I2C_BLOCK_DATA, &amp;data);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(values, &amp;data.block[<span class="number">1</span>], data.block[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> data.block[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_read_i2c_block_data()通过SMBus layer实现I2C block data数据传输，从slave device的特定寄存器读取一块数据（最多32 bytes），command参数描述读取的寄存器的地址，length参数为需要读取的数据的字节数，values指针用于保存读取的数据</p>
<p>返回成功读取的数据的字节数，否则返回负的错误码</p>
<h5 id="i2c-smbus-write-i2c-block-data"><a href="#i2c-smbus-write-i2c-block-data" class="headerlink" title="i2c_smbus_write_i2c_block_data"></a>i2c_smbus_write_i2c_block_data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">s32 <span class="title">i2c_smbus_write_i2c_block_data</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> i2c_client *client, u8 command,</span><br><span class="line">				   u8 length, <span class="keyword">const</span> u8 *values)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (length &gt; I2C_SMBUS_BLOCK_MAX)</span><br><span class="line">		length = I2C_SMBUS_BLOCK_MAX;</span><br><span class="line">	data.block[<span class="number">0</span>] = length;</span><br><span class="line">	<span class="built_in">memcpy</span>(data.block + <span class="number">1</span>, values, length);</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">			      I2C_SMBUS_WRITE, command,</span><br><span class="line">			      I2C_SMBUS_I2C_BLOCK_DATA, &amp;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_write_i2c_block_data()通过SMBus layer实现I2C block data数据传输，向slave device的特定寄存器写入一块数据（最多32 bytes），command参数描述写入的寄存器的地址，values指针保存需要写入的数据，length参数为需要写入的数据的字节数</p>
<p>成功返回0，否则返回负的错误码</p>
<h5 id="i2c-smbus-xfer-emulated"><a href="#i2c-smbus-xfer-emulated" class="headerlink" title="i2c_smbus_xfer_emulated"></a>i2c_smbus_xfer_emulated</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> s32 <span class="title">i2c_smbus_xfer_emulated</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter, u16 addr,</span><br><span class="line">				   <span class="keyword">unsigned</span> <span class="keyword">short</span> flags,</span><br><span class="line">				   <span class="keyword">char</span> read_write, u8 command, <span class="keyword">int</span> size,</span><br><span class="line">				   <span class="keyword">union</span> i2c_smbus_data *data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* So we need to generate a series of msgs. In the case of writing, we</span><br><span class="line">	  need to use only one message; when reading, we need two. We initialize</span><br><span class="line">	  most things with sane defaults, to keep the code below somewhat</span><br><span class="line">	  simpler. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> msgbuf0[I2C_SMBUS_BLOCK_MAX+<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> msgbuf1[I2C_SMBUS_BLOCK_MAX+<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> num = read_write == I2C_SMBUS_READ ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	u8 partial_pec = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> status;</span><br><span class="line">	<span class="keyword">struct</span> i2c_msg msg[<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			.addr = addr,</span><br><span class="line">			.flags = flags,</span><br><span class="line">			.len = <span class="number">1</span>,</span><br><span class="line">			.buf = msgbuf0,</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			.addr = addr,</span><br><span class="line">			.flags = flags | I2C_M_RD,</span><br><span class="line">			.len = <span class="number">0</span>,</span><br><span class="line">			.buf = msgbuf1,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	msgbuf0[<span class="number">0</span>] = command;</span><br><span class="line">	<span class="keyword">switch</span> (size) &#123;</span><br><span class="line">	<span class="keyword">case</span> I2C_SMBUS_QUICK:</span><br><span class="line">		msg[<span class="number">0</span>].len = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/* Special case: The read/write field is used as data */</span></span><br><span class="line">		msg[<span class="number">0</span>].flags = flags | (read_write == I2C_SMBUS_READ ?</span><br><span class="line">					I2C_M_RD : <span class="number">0</span>);</span><br><span class="line">		num = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> I2C_SMBUS_BYTE:</span><br><span class="line">		<span class="keyword">if</span> (read_write == I2C_SMBUS_READ) &#123;</span><br><span class="line">			<span class="comment">/* Special case: only a read! */</span></span><br><span class="line">			msg[<span class="number">0</span>].flags = I2C_M_RD | flags;</span><br><span class="line">			num = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> I2C_SMBUS_BYTE_DATA:</span><br><span class="line">		<span class="keyword">if</span> (read_write == I2C_SMBUS_READ)</span><br><span class="line">			msg[<span class="number">1</span>].len = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			msg[<span class="number">0</span>].len = <span class="number">2</span>;</span><br><span class="line">			msgbuf0[<span class="number">1</span>] = data-&gt;byte;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> I2C_SMBUS_WORD_DATA:</span><br><span class="line">		<span class="keyword">if</span> (read_write == I2C_SMBUS_READ)</span><br><span class="line">			msg[<span class="number">1</span>].len = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			msg[<span class="number">0</span>].len = <span class="number">3</span>;</span><br><span class="line">			msgbuf0[<span class="number">1</span>] = data-&gt;word &amp; <span class="number">0xff</span>;</span><br><span class="line">			msgbuf0[<span class="number">2</span>] = data-&gt;word &gt;&gt; <span class="number">8</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> I2C_SMBUS_PROC_CALL:</span><br><span class="line">		num = <span class="number">2</span>; <span class="comment">/* Special case */</span></span><br><span class="line">		read_write = I2C_SMBUS_READ;</span><br><span class="line">		msg[<span class="number">0</span>].len = <span class="number">3</span>;</span><br><span class="line">		msg[<span class="number">1</span>].len = <span class="number">2</span>;</span><br><span class="line">		msgbuf0[<span class="number">1</span>] = data-&gt;word &amp; <span class="number">0xff</span>;</span><br><span class="line">		msgbuf0[<span class="number">2</span>] = data-&gt;word &gt;&gt; <span class="number">8</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> I2C_SMBUS_BLOCK_DATA:</span><br><span class="line">		<span class="keyword">if</span> (read_write == I2C_SMBUS_READ) &#123;</span><br><span class="line">			msg[<span class="number">1</span>].flags |= I2C_M_RECV_LEN;</span><br><span class="line">			msg[<span class="number">1</span>].len = <span class="number">1</span>; <span class="comment">/* block length will be added by</span><br><span class="line">					   the underlying bus driver */</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			msg[<span class="number">0</span>].len = data-&gt;block[<span class="number">0</span>] + <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (msg[<span class="number">0</span>].len &gt; I2C_SMBUS_BLOCK_MAX + <span class="number">2</span>) &#123;</span><br><span class="line">				dev_err(&amp;adapter-&gt;dev,</span><br><span class="line">					<span class="string">"Invalid block write size %d\n"</span>,</span><br><span class="line">					data-&gt;block[<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; msg[<span class="number">0</span>].len; i++)</span><br><span class="line">				msgbuf0[i] = data-&gt;block[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> I2C_SMBUS_BLOCK_PROC_CALL:</span><br><span class="line">		num = <span class="number">2</span>; <span class="comment">/* Another special case */</span></span><br><span class="line">		read_write = I2C_SMBUS_READ;</span><br><span class="line">		<span class="keyword">if</span> (data-&gt;block[<span class="number">0</span>] &gt; I2C_SMBUS_BLOCK_MAX) &#123;</span><br><span class="line">			dev_err(&amp;adapter-&gt;dev,</span><br><span class="line">				<span class="string">"Invalid block write size %d\n"</span>,</span><br><span class="line">				data-&gt;block[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		msg[<span class="number">0</span>].len = data-&gt;block[<span class="number">0</span>] + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; msg[<span class="number">0</span>].len; i++)</span><br><span class="line">			msgbuf0[i] = data-&gt;block[i<span class="number">-1</span>];</span><br><span class="line">		msg[<span class="number">1</span>].flags |= I2C_M_RECV_LEN;</span><br><span class="line">		msg[<span class="number">1</span>].len = <span class="number">1</span>; <span class="comment">/* block length will be added by</span><br><span class="line">				   the underlying bus driver */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> I2C_SMBUS_I2C_BLOCK_DATA:</span><br><span class="line">		<span class="keyword">if</span> (read_write == I2C_SMBUS_READ) &#123;</span><br><span class="line">			msg[<span class="number">1</span>].len = data-&gt;block[<span class="number">0</span>];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			msg[<span class="number">0</span>].len = data-&gt;block[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (msg[<span class="number">0</span>].len &gt; I2C_SMBUS_BLOCK_MAX + <span class="number">1</span>) &#123;</span><br><span class="line">				dev_err(&amp;adapter-&gt;dev,</span><br><span class="line">					<span class="string">"Invalid block write size %d\n"</span>,</span><br><span class="line">					data-&gt;block[<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= data-&gt;block[<span class="number">0</span>]; i++)</span><br><span class="line">				msgbuf0[i] = data-&gt;block[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		dev_err(&amp;adapter-&gt;dev, <span class="string">"Unsupported transaction %d\n"</span>, size);</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i = ((flags &amp; I2C_CLIENT_PEC) &amp;&amp; size != I2C_SMBUS_QUICK</span><br><span class="line">				      &amp;&amp; size != I2C_SMBUS_I2C_BLOCK_DATA);</span><br><span class="line">	<span class="keyword">if</span> (i) &#123;</span><br><span class="line">		<span class="comment">/* Compute PEC if first message is a write */</span></span><br><span class="line">		<span class="keyword">if</span> (!(msg[<span class="number">0</span>].flags &amp; I2C_M_RD)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (num == <span class="number">1</span>) <span class="comment">/* Write only */</span></span><br><span class="line">				i2c_smbus_add_pec(&amp;msg[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">else</span> <span class="comment">/* Write followed by read */</span></span><br><span class="line">				partial_pec = i2c_smbus_msg_pec(<span class="number">0</span>, &amp;msg[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* Ask for PEC if last message is a read */</span></span><br><span class="line">		<span class="keyword">if</span> (msg[num<span class="number">-1</span>].flags &amp; I2C_M_RD)</span><br><span class="line">			msg[num<span class="number">-1</span>].len++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	status = i2c_transfer(adapter, msg, num);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check PEC if last message is a read */</span></span><br><span class="line">	<span class="keyword">if</span> (i &amp;&amp; (msg[num<span class="number">-1</span>].flags &amp; I2C_M_RD)) &#123;</span><br><span class="line">		status = i2c_smbus_check_pec(partial_pec, &amp;msg[num<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (read_write == I2C_SMBUS_READ)</span><br><span class="line">		<span class="keyword">switch</span> (size) &#123;</span><br><span class="line">		<span class="keyword">case</span> I2C_SMBUS_BYTE:</span><br><span class="line">			data-&gt;byte = msgbuf0[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> I2C_SMBUS_BYTE_DATA:</span><br><span class="line">			data-&gt;byte = msgbuf1[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> I2C_SMBUS_WORD_DATA:</span><br><span class="line">		<span class="keyword">case</span> I2C_SMBUS_PROC_CALL:</span><br><span class="line">			data-&gt;word = msgbuf1[<span class="number">0</span>] | (msgbuf1[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> I2C_SMBUS_I2C_BLOCK_DATA:</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; data-&gt;block[<span class="number">0</span>]; i++)</span><br><span class="line">				data-&gt;block[i+<span class="number">1</span>] = msgbuf1[i];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> I2C_SMBUS_BLOCK_DATA:</span><br><span class="line">		<span class="keyword">case</span> I2C_SMBUS_BLOCK_PROC_CALL:</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; msgbuf1[<span class="number">0</span>] + <span class="number">1</span>; i++)</span><br><span class="line">				data-&gt;block[i] = msgbuf1[i];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_xfer_emulated()使用standard I2C protocol模拟SMBus protocol进行数据传输</p>
<p>@adapter     需要传输数据的 smbus<br>@addr        数据传输的目标slave device的i2c地址<br>@flags       数据传输的标志，I2C<em>CLIENT</em>*标志集<br>@read_write  数据发送或接收的标志位，I2C_SMBUS_READ or I2C_SMBUS_WRITE<br>@command     Byte interpreted by slave，通常表示slave device需要读取或写入的寄存器地址<br>@size    描述需要执行的SMBus protocol operation的类型，如I2C_SMBUS_BYTE_DATA等，通常表示传输的数据的大小<br>@data        需要传输的数据</p>
<p>成功返回0，否则返回负的错误码，若当前为读操作，则data参数中保存读取的数据</p>
<p>使用standard I2C protocol模拟SMBus protocol时</p>
<ul>
<li>SMBus protocol的write操作对应一个i2c message，即slave device i2c address与write data的传输方向均为 master -&gt; slave，因而只需一个i2c message</li>
<li>SMBus protocol的read操作对应两个i2c message，即slave device i2c address的传输方向为 master -&gt; slave，而write data的传输方向均为 slave -&gt; master，因而需要两个i2c message</li>
</ul>
<p>i2c_smbus_xfer_emulated()中定义两个i2c message，其中msg[0]的传输方向为master -&gt; slave，msg[1]的传输方向为 slave -&gt; master</p>
<ul>
<li>msg[0]对应的data buffer为msgbuf0[]，其中存储SMBus command即操作的寄存器地址</li>
<li>msg[1]对应的data buffer为msgbuf1[]</li>
</ul>
<p>之后只需根据SMBus的不同protocol对i2c message进行设置，之后调用i2c_transfer()传输相应的i2c message</p>
<ul>
<li>定义两个i2c message msg[2]</li>
<li>将msgbuf0[0]设置为传入的command参数</li>
<li>根据传入的size参数即需要传输的数据大小，设置相应的i2c message</li>
<li>若传入的flags标志位包含I2C_CLIENT_PEC即启用CRC校验，同时传入的size参数不为I2C_SMBUS_QUICK、I2C_SMBUS_I2C_BLOCK_DATA即QUICK、I2C_BLOCK_DATA不支持SMBus PEC，则启用SMBus PEC，并向i2c message中添加CRC byte</li>
<li>调用i2c_transfer()传输相应的i2c message，若传输失败则函数直接返回相应的错误码</li>
<li>若之前启用SMBus PEC，且当前操作为读操作时，对读取的数据进行CRC校验，若校验存在错误则函数直接返回相应的错误码</li>
<li>若当前操作为读操作，则将读取的数据保存在传入的data参数中，最后函数返回0</li>
</ul>
<h4 id="I2C-Sysfs"><a href="#I2C-Sysfs" class="headerlink" title="I2C Sysfs"></a>I2C Sysfs</h4><h5 id="i2c-adapter-sysfs"><a href="#i2c-adapter-sysfs" class="headerlink" title="i2c adapter sysfs"></a>i2c adapter sysfs</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_type i2c_adapter_type = &#123;</span><br><span class="line">	.groups		= i2c_adapter_attr_groups,</span><br><span class="line">	.release	= i2c_adapter_dev_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>i2c_adapter_type 为i2c adapter对应的device的device_type</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> attribute_group *i2c_adapter_attr_groups[] = &#123;</span><br><span class="line">	&amp;i2c_adapter_attr_group,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> attribute_group i2c_adapter_attr_group = &#123;</span><br><span class="line">	.attrs		= i2c_adapter_attrs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> attribute *i2c_adapter_attrs[] = &#123;</span><br><span class="line">	&amp;dev_attr_name.attr,</span><br><span class="line">	&amp;dev_attr_new_device.attr,</span><br><span class="line">	&amp;dev_attr_delete_device.attr,</span><br><span class="line">	&amp;dev_attr_bus_clk_rate.attr,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>i2c adapter对应的 /sys/bus/i2c/devices/i2c-n/ 文件夹下存在name、new_device、delete_device、bus_clk_rate属性文件</p>
<h6 id="name"><a href="#name" class="headerlink" title="name"></a>name</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(name, S_IRUGO, show_name, <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t</span><br><span class="line"><span class="title">show_name</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, <span class="keyword">char</span> *buf)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">"%s\n"</span>, dev-&gt;type == &amp;i2c_client_type ?</span><br><span class="line">		       to_i2c_client(dev)-&gt;name : to_i2c_adapter(dev)-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>name属性文件可读，返回对应的i2c adapter的name字段，即该i2c adapter的名称；不可写</p>
<h6 id="new-device"><a href="#new-device" class="headerlink" title="new_device"></a>new_device</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(new_device, S_IWUSR, <span class="literal">NULL</span>, i2c_sysfs_new_device)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t</span><br><span class="line"><span class="title">i2c_sysfs_new_device</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">		     <span class="keyword">const</span> <span class="keyword">char</span> *buf, size_t count)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *adap = to_i2c_adapter(dev);</span><br><span class="line">	<span class="keyword">struct</span> i2c_board_info info;</span><br><span class="line">	<span class="keyword">struct</span> i2c_client *client;</span><br><span class="line">	<span class="keyword">char</span> *blank, end;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> i2c_board_info));</span><br><span class="line"></span><br><span class="line">	blank = <span class="built_in">strchr</span>(buf, <span class="string">' '</span>);</span><br><span class="line">	<span class="keyword">if</span> (!blank) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">"%s: Missing parameters\n"</span>, <span class="string">"new_device"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (blank - buf &gt; I2C_NAME_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">"%s: Invalid device name\n"</span>, <span class="string">"new_device"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(info.type, buf, blank - buf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Parse remaining parameters, reject extra parameters */</span></span><br><span class="line">	res = <span class="built_in">sscanf</span>(++blank, <span class="string">"%hi%c"</span>, &amp;info.addr, &amp;end);</span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">1</span>) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">"%s: Can't parse I2C address\n"</span>, <span class="string">"new_device"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (res &gt; <span class="number">1</span>  &amp;&amp; end != <span class="string">'\n'</span>) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">"%s: Extra parameters\n"</span>, <span class="string">"new_device"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	client = i2c_new_device(adap, &amp;info);</span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Keep track of the added device */</span></span><br><span class="line">	mutex_lock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">	list_add_tail(&amp;client-&gt;detected, &amp;adap-&gt;userspace_clients);</span><br><span class="line">	mutex_unlock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line">	dev_info(dev, <span class="string">"%s: Instantiated device %s at 0x%02hx\n"</span>, <span class="string">"new_device"</span>,</span><br><span class="line">		 info.type, info.addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new_device属性文件不可读；可写，用于在该i2c adapter下创建特定名称，特定地址的i2c client</p>
<p>写入的字符串的格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;name&gt; 0x&lt;i2c_address&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <name> 为新创建的i2c client的名称，<i2c_address>为i2c client的地址</i2c_address></name></p>
<h6 id="delete-device"><a href="#delete-device" class="headerlink" title="delete_device"></a>delete_device</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR_IGNORE_LOCKDEP</span><span class="params">(delete_device, S_IWUSR, <span class="literal">NULL</span>,</span><br><span class="line">				   i2c_sysfs_delete_device)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t</span><br><span class="line"><span class="title">i2c_sysfs_delete_device</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span> *buf, size_t count)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *adap = to_i2c_adapter(dev);</span><br><span class="line">	<span class="keyword">struct</span> i2c_client *client, *next;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> addr;</span><br><span class="line">	<span class="keyword">char</span> end;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Parse parameters, reject extra parameters */</span></span><br><span class="line">	res = <span class="built_in">sscanf</span>(buf, <span class="string">"%hi%c"</span>, &amp;addr, &amp;end);</span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">1</span>) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">"%s: Can't parse I2C address\n"</span>, <span class="string">"delete_device"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (res &gt; <span class="number">1</span>  &amp;&amp; end != <span class="string">'\n'</span>) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">"%s: Extra parameters\n"</span>, <span class="string">"delete_device"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Make sure the device was added through sysfs */</span></span><br><span class="line">	res = -ENOENT;</span><br><span class="line">	mutex_lock_nested(&amp;adap-&gt;userspace_clients_lock,</span><br><span class="line">			  i2c_adapter_depth(adap));</span><br><span class="line">	list_for_each_entry_safe(client, next, &amp;adap-&gt;userspace_clients,</span><br><span class="line">				 detected) &#123;</span><br><span class="line">		<span class="keyword">if</span> (client-&gt;addr == addr) &#123;</span><br><span class="line">			dev_info(dev, <span class="string">"%s: Deleting device %s at 0x%02hx\n"</span>,</span><br><span class="line">				 <span class="string">"delete_device"</span>, client-&gt;name, client-&gt;addr);</span><br><span class="line"></span><br><span class="line">			list_del(&amp;client-&gt;detected);</span><br><span class="line">			i2c_unregister_device(client);</span><br><span class="line">			res = count;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;adap-&gt;userspace_clients_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">		dev_err(dev, <span class="string">"%s: Can't find device in list\n"</span>,</span><br><span class="line">			<span class="string">"delete_device"</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete_device属性文件不可读；可写，与new_device相类似，用于删除该i2c adapter下的特定的i2c client</p>
<p>写入的字符串的格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x&lt;i2c_address&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <i2c_address>为需要删除的i2c client的地址</i2c_address></p>
<h6 id="bus-clk-rate"><a href="#bus-clk-rate" class="headerlink" title="bus_clk_rate"></a>bus_clk_rate</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(bus_clk_rate, <span class="number">0644</span>, show_bus_clk_rate, set_bus_clk_rate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">show_bus_clk_rate</span><span class="params">(<span class="keyword">struct</span> device *dev,</span><br><span class="line">		<span class="keyword">struct</span> device_attribute *attr, <span class="keyword">char</span> *buf)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *adap = to_i2c_adapter(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">"%ld\n"</span>, adap-&gt;bus_clk_rate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">set_bus_clk_rate</span><span class="params">(<span class="keyword">struct</span> device *dev,</span><br><span class="line">		<span class="keyword">struct</span> device_attribute *attr, <span class="keyword">const</span> <span class="keyword">char</span> *buf, size_t count)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *adap = to_i2c_adapter(dev);</span><br><span class="line">	<span class="keyword">char</span> *p = (<span class="keyword">char</span> *)buf;</span><br><span class="line">	<span class="keyword">int</span> bus_clk_rate;</span><br><span class="line"></span><br><span class="line">	bus_clk_rate = memparse(p, &amp;p);</span><br><span class="line">	dev_info(dev, <span class="string">"Setting clock rate %d on next transfer\n"</span>, bus_clk_rate);</span><br><span class="line">	adap-&gt;bus_clk_rate = bus_clk_rate;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bus_clk_rate属性文件可读，返回该i2c adapter的bus_clk_rate；可写，设置该i2c adapter的bus_clk_rate</p>
<h5 id="i2c-client-sysfs"><a href="#i2c-client-sysfs" class="headerlink" title="i2c client sysfs"></a>i2c client sysfs</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> device_type i2c_client_type = &#123;</span><br><span class="line">	.groups		= i2c_dev_attr_groups,</span><br><span class="line">	.uevent		= i2c_device_uevent,</span><br><span class="line">	.release	= i2c_client_dev_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>i2c_client_type()为i2c client对应的device的device_type</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> attribute_group *i2c_dev_attr_groups[] = &#123;</span><br><span class="line">	&amp;i2c_dev_attr_group,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> attribute_group i2c_dev_attr_group = &#123;</span><br><span class="line">	.attrs		= i2c_dev_attrs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> attribute *i2c_dev_attrs[] = &#123;</span><br><span class="line">	&amp;dev_attr_name.attr,</span><br><span class="line">	<span class="comment">/* modalias helps coldplug:  modprobe $(cat .../modalias) */</span></span><br><span class="line">	&amp;dev_attr_modalias.attr,</span><br><span class="line">	<span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>i2c adapter对应的 /sys/bus/i2c/devices/n-xx/ 文件夹下存在name、modalias属性文件</p>
<h6 id="name-1"><a href="#name-1" class="headerlink" title="name"></a>name</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(name, S_IRUGO, show_name, <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t</span><br><span class="line"><span class="title">show_name</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, <span class="keyword">char</span> *buf)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">"%s\n"</span>, dev-&gt;type == &amp;i2c_client_type ?</span><br><span class="line">		       to_i2c_client(dev)-&gt;name : to_i2c_adapter(dev)-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>name属性文件可读，返回对应的i2c client的name字段，即该i2c client的名称；不可写</p>
<h6 id="modalias"><a href="#modalias" class="headerlink" title="modalias"></a>modalias</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEVICE_ATTR</span><span class="params">(modalias, S_IRUGO, show_modalias, <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t</span><br><span class="line"><span class="title">show_modalias</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, <span class="keyword">char</span> *buf)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_client *client = to_i2c_client(dev);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">"%s%s\n"</span>, I2C_MODULE_PREFIX, client-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_MODULE_PREFIX <span class="string">"i2c:"</span></span></span><br></pre></td></tr></table></figure>
<p>modalias属性文件可读，返回对应的i2c client的modalias信息，实际为<code>i2c:&lt;name&gt;</code>，其中 <name> 为i2c client的名称；不可写</name></p>
<h3 id="I2C-OF-Support"><a href="#I2C-OF-Support" class="headerlink" title="I2C OF Support"></a>I2C OF Support</h3><p><code>include/linux/of_i2c.h</code>与<code>drivers/of/of_i2c.c</code>中定义OF I2C接口</p>
<h4 id="I2C-OF-Interface"><a href="#I2C-OF-Interface" class="headerlink" title="I2C OF Interface"></a>I2C OF Interface</h4><h5 id="of-find-i2c-device-by-node"><a href="#of-find-i2c-device-by-node" class="headerlink" title="of_find_i2c_device_by_node"></a>of_find_i2c_device_by_node</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> i2c_client *<span class="title">of_find_i2c_device_by_node</span><span class="params">(<span class="keyword">struct</span> device_node *node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> device *dev;</span><br><span class="line"></span><br><span class="line">	dev = bus_find_device(&amp;i2c_bus_type, <span class="literal">NULL</span>, node,</span><br><span class="line">					 of_dev_node_match);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i2c_verify_client(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>of_find_i2c_device_by_node()在当前i2c bus中所有注册的i2c device中寻找特定device node对应的i2c client，若找到则返回该device node对应的i2c client，否则函数返回NULL</p>
<p>由于执行路径中当找到对应的i2c client时会调用调用get_device()，因而该函数返回后当对该i2c client执行完相应的操作之后，应该调用put_device()</p>
<h5 id="of-find-i2c-adapter-by-node"><a href="#of-find-i2c-adapter-by-node" class="headerlink" title="of_find_i2c_adapter_by_node"></a>of_find_i2c_adapter_by_node</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> i2c_adapter *<span class="title">of_find_i2c_adapter_by_node</span><span class="params">(<span class="keyword">struct</span> device_node *node)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> device *dev;</span><br><span class="line"></span><br><span class="line">	dev = bus_find_device(&amp;i2c_bus_type, <span class="literal">NULL</span>, node,</span><br><span class="line">					 of_dev_node_match);</span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i2c_verify_adapter(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>of_find_i2c_adapter_by_node()在当前i2c bus中所有注册的i2c device中寻找特定device node对应的i2c adapter，若找到则返回该device node对应的i2c adapter，否则函数返回NULL</p>
<p>由于执行路径中当找到对应的i2c adapter时会调用调用get_device()，因而该函数返回后当对该i2c adapter执行完相应的操作之后，应该调用put_device()</p>
<h5 id="of-i2c-register-devices"><a href="#of-i2c-register-devices" class="headerlink" title="of_i2c_register_devices"></a>of_i2c_register_devices</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">of_i2c_register_devices</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *result;</span><br><span class="line">	<span class="keyword">struct</span> device_node *node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Only register child devices if the adapter has a node pointer set */</span></span><br><span class="line">	<span class="keyword">if</span> (!adap-&gt;dev.of_node)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;adap-&gt;dev, <span class="string">"of_i2c: walking child nodes\n"</span>);</span><br><span class="line"></span><br><span class="line">	for_each_available_child_of_node(adap-&gt;dev.of_node, node) &#123;</span><br><span class="line">		<span class="keyword">struct</span> i2c_board_info info = &#123;&#125;;</span><br><span class="line">		<span class="keyword">struct</span> dev_archdata dev_ad = &#123;&#125;;</span><br><span class="line">		<span class="keyword">const</span> __be32 *addr;</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">		dev_dbg(&amp;adap-&gt;dev, <span class="string">"of_i2c: register %s\n"</span>, node-&gt;full_name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (of_modalias_node(node, info.type, <span class="keyword">sizeof</span>(info.type)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			dev_err(&amp;adap-&gt;dev, <span class="string">"of_i2c: modalias failure on %s\n"</span>,</span><br><span class="line">				node-&gt;full_name);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		addr = of_get_property(node, <span class="string">"reg"</span>, &amp;len);</span><br><span class="line">		<span class="keyword">if</span> (!addr || (len &lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>))) &#123;</span><br><span class="line">			dev_err(&amp;adap-&gt;dev, <span class="string">"of_i2c: invalid reg on %s\n"</span>,</span><br><span class="line">				node-&gt;full_name);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		info.addr = be32_to_cpup(addr);</span><br><span class="line">		<span class="keyword">if</span> (info.addr &gt; (<span class="number">1</span> &lt;&lt; <span class="number">10</span>) - <span class="number">1</span>) &#123;</span><br><span class="line">			dev_err(&amp;adap-&gt;dev, <span class="string">"of_i2c: invalid addr=%x on %s\n"</span>,</span><br><span class="line">				info.addr, node-&gt;full_name);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		info.irq = irq_of_parse_and_map(node, <span class="number">0</span>);</span><br><span class="line">		info.of_node = of_node_get(node);</span><br><span class="line">		info.archdata = &amp;dev_ad;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (of_get_property(node, <span class="string">"wakeup-source"</span>, <span class="literal">NULL</span>))</span><br><span class="line">			info.flags |= I2C_CLIENT_WAKE;</span><br><span class="line"></span><br><span class="line">		request_module(<span class="string">"%s%s"</span>, I2C_MODULE_PREFIX, info.type);</span><br><span class="line"></span><br><span class="line">		result = i2c_new_device(adap, &amp;info);</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			dev_err(&amp;adap-&gt;dev, <span class="string">"of_i2c: Failure registering %s\n"</span>,</span><br><span class="line">			        node-&gt;full_name);</span><br><span class="line">			of_node_put(node);</span><br><span class="line">			irq_dispose_mapping(info.irq);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在设备树中定义i2c multiplexer (i2c mux channel) 及其下的i2c client时，调用of_i2c_register_devices()注册设备树中定义的该i2c mux channel下的所有i2c cleint</p>
<ul>
<li>遍历该i2c mux channel对应的i2c adapter的device的device node的所有child device node，其中的每个child device node表示该i2c mux channel下的一个i2c client，根据child device node中定义的信息初始化该i2c client对应的i2c_board_info</li>
<li>之后根据i2c_board_info结构调用i2c_new_device()为每个child device node创建对应的i2c client</li>
</ul>
<h3 id="I2C-Algorithm"><a href="#I2C-Algorithm" class="headerlink" title="I2C Algorithm"></a>I2C Algorithm</h3><p>i2c algorithm 描述i2c message传输的底层实现，i2c adapter可以实现自身特定的i2c algorithm，也可以直接使用<code>drivers/i2c/algos/</code>下定义的i2c algorithm</p>
<p><code>include/linux/i2c-algo-bit.h</code>与<code>drivers/i2c/algos/i2c-algo-bit.c</code>中定义 i2c bit-banging algorithm</p>
<p>bit-banging 是指通过设定signal pin的电平状态，由软件模拟实现串行总线的时序。若硬件已经集成总线时序的发送与接收，那么向硬件的特定寄存器写入一个字节的数据，硬件自身就可以生成该字节的时序，而bit-banging则必须由软件以bit为单位生成该字节的时序；bit-banging会增大软件开销以及CPU的负担，但可以减小硬件成本</p>
<h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="i2c-algo-bit-data"><a href="#i2c-algo-bit-data" class="headerlink" title="i2c_algo_bit_data"></a>i2c_algo_bit_data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_algo_bit_data &#123;</span><br><span class="line">	<span class="keyword">void</span> *data;		<span class="comment">/* private data for lowlevel routines */</span></span><br><span class="line">	<span class="keyword">void</span> (*setsda) (<span class="keyword">void</span> *data, <span class="keyword">int</span> state);</span><br><span class="line">	<span class="keyword">void</span> (*setscl) (<span class="keyword">void</span> *data, <span class="keyword">int</span> state);</span><br><span class="line">	<span class="keyword">int</span>  (*getsda) (<span class="keyword">void</span> *data);</span><br><span class="line">	<span class="keyword">int</span>  (*getscl) (<span class="keyword">void</span> *data);</span><br><span class="line">	<span class="keyword">int</span>  (*pre_xfer)  (<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line">	<span class="keyword">void</span> (*post_xfer) (<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* local settings */</span></span><br><span class="line">	<span class="keyword">int</span> udelay;		<span class="comment">/* half clock cycle time in us,</span><br><span class="line">				   minimum 2 us for fast-mode I2C,</span><br><span class="line">				   minimum 5 us for standard-mode I2C and SMBus,</span><br><span class="line">				   maximum 50 us for SMBus */</span></span><br><span class="line">	<span class="keyword">int</span> timeout;		<span class="comment">/* in jiffies */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct i2c_algo_bit_data抽象bit-banging algorithm使用的数据，其中定义hw-specific回调函数</p>
<p>@data       i2c adapter chip specific数据结构<br>@udelay     i2c bus clock时钟周期的一半，以us为单位<br>@timeout    SCL line由低电平变为高电平的过程允许的超时时间</p>
<p>@setsda     用于将SDA signal的电平设置为state，data参数通常为该结构的data字段<br>@setscl     用于将SCL signal的电平设置为state，data参数通常为该结构的data字段<br>@getsda     用于获取SDA signal的电平状态，data参数通常为该结构的data字段<br>@getscl     用于获取SCL signal的电平状态，data参数通常为该结构的data字段<br>@pre_xfer   用于执行数据传输前的一些准备工作，data参数通常为该结构的data字段<br>@post_xfer  用于执行数据传输后的一些清理工作，data参数通常为该结构的data字段</p>
<h4 id="Signal-Manipulation"><a href="#Signal-Manipulation" class="headerlink" title="Signal Manipulation"></a>Signal Manipulation</h4><h5 id="SDA-SCL-Manipulation"><a href="#SDA-SCL-Manipulation" class="headerlink" title="SDA/SCL Manipulation"></a>SDA/SCL Manipulation</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> setsda(adap, val)	adap-&gt;setsda(adap-&gt;data, val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> setscl(adap, val)	adap-&gt;setscl(adap-&gt;data, val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getsda(adap)		adap-&gt;getsda(adap-&gt;data)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getscl(adap)		adap-&gt;getscl(adap-&gt;data)</span></span><br></pre></td></tr></table></figure>
<p>getsda()/setsda() 获取/设置SDA signal的电平状态<br>getscl()/setscl() 获取/设置SCL signal的电平状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdalo</span><span class="params">(<span class="keyword">struct</span> i2c_algo_bit_data *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	setsda(adap, <span class="number">0</span>);</span><br><span class="line">	udelay((adap-&gt;udelay + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sdalo()拉低 SDA line，并使其低电平状态维持 1/4 周期</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdahi</span><span class="params">(<span class="keyword">struct</span> i2c_algo_bit_data *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	setsda(adap, <span class="number">1</span>);</span><br><span class="line">	udelay((adap-&gt;udelay + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sdahi()拉高 SDA line，并使其高电平状态维持 1/4 周期</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">scllo</span><span class="params">(<span class="keyword">struct</span> i2c_algo_bit_data *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	setscl(adap, <span class="number">0</span>);</span><br><span class="line">	udelay(adap-&gt;udelay / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scllo()拉低SCL line，并使其低电平状态维持 1/4 周期</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sclhi</span><span class="params">(<span class="keyword">struct</span> i2c_algo_bit_data *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line">	setscl(adap, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Not all adapters have scl sense line... */</span></span><br><span class="line">	<span class="keyword">if</span> (!adap-&gt;getscl)</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">	start = jiffies;</span><br><span class="line">	<span class="keyword">while</span> (!getscl(adap)) &#123;</span><br><span class="line">		<span class="comment">/* This hw knows how to read the clock line, so we wait</span><br><span class="line">		 * until it actually gets high.  This is safer as some</span><br><span class="line">		 * chips may hold it low ("clock stretching") while they</span><br><span class="line">		 * are processing data internally.</span><br><span class="line">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (time_after(jiffies, start + adap-&gt;timeout)) &#123;</span><br><span class="line">			<span class="comment">/* Test one last time, as we may have been preempted</span><br><span class="line">			 * between last check and timeout test.</span><br><span class="line">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (getscl(adap))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">return</span> -ETIMEDOUT;</span><br><span class="line">		&#125;</span><br><span class="line">		cpu_relax();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">	<span class="keyword">if</span> (jiffies != start &amp;&amp; i2c_debug &gt;= <span class="number">3</span>)</span><br><span class="line">		pr_debug(<span class="string">"i2c-algo-bit: needed %ld jiffies for SCL to go "</span></span><br><span class="line">			 <span class="string">"high\n"</span>, jiffies - start);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	udelay(adap-&gt;udelay);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sclhi()拉高SCL line，同时若这一上升过程的时间超过i2c_algo_bit_data的timeout成员规定的允许的超时时间，则函数返回-ETIMEDOUT，否则将SCL line的高电平状态维持 1/2 时钟周期后，函数返回0</p>
<h5 id="i2c-start"><a href="#i2c-start" class="headerlink" title="i2c_start"></a>i2c_start</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">i2c_start</span><span class="params">(<span class="keyword">struct</span> i2c_algo_bit_data *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* assert: scl, sda are high */</span></span><br><span class="line">	setsda(adap, <span class="number">0</span>);</span><br><span class="line">	udelay(adap-&gt;udelay);</span><br><span class="line">	scllo(adap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_start()在SCL高电平期间将SDA由高电平变为低电平，以产生开始信号S</p>
<h5 id="i2c-repstart"><a href="#i2c-repstart" class="headerlink" title="i2c_repstart"></a>i2c_repstart</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">i2c_repstart</span><span class="params">(<span class="keyword">struct</span> i2c_algo_bit_data *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* assert: scl is low */</span></span><br><span class="line">	sdahi(adap);</span><br><span class="line">	sclhi(adap);</span><br><span class="line">	setsda(adap, <span class="number">0</span>);</span><br><span class="line">	udelay(adap-&gt;udelay);</span><br><span class="line">	scllo(adap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_repstart()将SDA、SCL恢复为高电平之后，拉低SDA以产生开始信号S</p>
<h5 id="i2c-stop"><a href="#i2c-stop" class="headerlink" title="i2c_stop"></a>i2c_stop</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">i2c_stop</span><span class="params">(<span class="keyword">struct</span> i2c_algo_bit_data *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* assert: scl is low */</span></span><br><span class="line">	sdalo(adap);</span><br><span class="line">	sclhi(adap);</span><br><span class="line">	setsda(adap, <span class="number">1</span>);</span><br><span class="line">	udelay(adap-&gt;udelay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_stop()在SCL高电平期间将SDA由低电平变为高电平，以产生结束信号P</p>
<h4 id="Protocol-Manipulation"><a href="#Protocol-Manipulation" class="headerlink" title="Protocol Manipulation"></a>Protocol Manipulation</h4><h5 id="i2c-inb"><a href="#i2c-inb" class="headerlink" title="i2c_inb"></a>i2c_inb</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_inb</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *i2c_adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">/* read byte via i2c port, without start/stop sequence	*/</span></span><br><span class="line">	<span class="comment">/* acknowledge is sent in i2c_read.			*/</span></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> indata = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">struct</span> i2c_algo_bit_data *adap = i2c_adap-&gt;algo_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* assert: scl is low */</span></span><br><span class="line">	sdahi(adap);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sclhi(adap) &lt; <span class="number">0</span>) &#123; <span class="comment">/* timeout */</span></span><br><span class="line">			bit_err(&amp;i2c_adap-&gt;dev, <span class="string">"i2c_inb: timeout at bit "</span></span><br><span class="line">				<span class="string">"#%d\n"</span>, <span class="number">7</span> - i);</span><br><span class="line">			<span class="keyword">return</span> -ETIMEDOUT;</span><br><span class="line">		&#125;</span><br><span class="line">		indata *= <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (getsda(adap))</span><br><span class="line">			indata |= <span class="number">0x01</span>;</span><br><span class="line">		setscl(adap, <span class="number">0</span>);</span><br><span class="line">		udelay(i == <span class="number">7</span> ? adap-&gt;udelay / <span class="number">2</span> : adap-&gt;udelay);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* assert: scl is low */</span></span><br><span class="line">	<span class="keyword">return</span> indata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_outb()向i2c bus读取一个字节的数据，函数返回读取的一个字节的数据</p>
<h5 id="i2c-outb"><a href="#i2c-outb" class="headerlink" title="i2c_outb"></a>i2c_outb</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_outb</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *i2c_adap, <span class="keyword">unsigned</span> <span class="keyword">char</span> c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> sb;</span><br><span class="line">	<span class="keyword">int</span> ack;</span><br><span class="line">	<span class="keyword">struct</span> i2c_algo_bit_data *adap = i2c_adap-&gt;algo_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* assert: scl is low */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		sb = (c &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">		setsda(adap, sb);</span><br><span class="line">		udelay((adap-&gt;udelay + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span> (sclhi(adap) &lt; <span class="number">0</span>) &#123; <span class="comment">/* timed out */</span></span><br><span class="line">			bit_err(&amp;i2c_adap-&gt;dev, <span class="string">"i2c_outb: 0x%02x, "</span></span><br><span class="line">				<span class="string">"timeout at bit #%d\n"</span>, (<span class="keyword">int</span>)c, i);</span><br><span class="line">			<span class="keyword">return</span> -ETIMEDOUT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* FIXME do arbitration here:</span><br><span class="line">		 * if (sb &amp;&amp; !getsda(adap)) -&gt; ouch! Get out of here.</span><br><span class="line">		 *</span><br><span class="line">		 * Report a unique code, so higher level code can retry</span><br><span class="line">		 * the whole (combined) message and *NOT* issue STOP.</span><br><span class="line">		 */</span></span><br><span class="line">		scllo(adap);</span><br><span class="line">	&#125;</span><br><span class="line">	sdahi(adap);</span><br><span class="line">	<span class="keyword">if</span> (sclhi(adap) &lt; <span class="number">0</span>) &#123; <span class="comment">/* timeout */</span></span><br><span class="line">		bit_err(&amp;i2c_adap-&gt;dev, <span class="string">"i2c_outb: 0x%02x, "</span></span><br><span class="line">			<span class="string">"timeout at ack\n"</span>, (<span class="keyword">int</span>)c);</span><br><span class="line">		<span class="keyword">return</span> -ETIMEDOUT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* read ack: SDA should be pulled down by slave, or it may</span><br><span class="line">	 * NAK (usually to report problems with the data we wrote).</span><br><span class="line">	 */</span></span><br><span class="line">	ack = !getsda(adap);    <span class="comment">/* ack: sda is pulled low -&gt; success */</span></span><br><span class="line">	bit_dbg(<span class="number">2</span>, &amp;i2c_adap-&gt;dev, <span class="string">"i2c_outb: 0x%02x %s\n"</span>, (<span class="keyword">int</span>)c,</span><br><span class="line">		ack ? <span class="string">"A"</span> : <span class="string">"NA"</span>);</span><br><span class="line"></span><br><span class="line">	scllo(adap);</span><br><span class="line">	<span class="keyword">return</span> ack;</span><br><span class="line">	<span class="comment">/* assert: scl is low (sda undef) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_outb()向i2c bus发送一个字节的数据，同时接收应答信号，若数据发送失败函数返回-ETIMEDOUT，否则若收到ack信号则返回1，否则返回0</p>
<h5 id="bit-doAddress"><a href="#bit-doAddress" class="headerlink" title="bit_doAddress"></a>bit_doAddress</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bit_doAddress</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *i2c_adap, <span class="keyword">struct</span> i2c_msg *msg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> flags = msg-&gt;flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> nak_ok = msg-&gt;flags &amp; I2C_M_IGNORE_NAK;</span><br><span class="line">	<span class="keyword">struct</span> i2c_algo_bit_data *adap = i2c_adap-&gt;algo_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> addr;</span><br><span class="line">	<span class="keyword">int</span> ret, retries;</span><br><span class="line"></span><br><span class="line">	retries = nak_ok ? <span class="number">0</span> : i2c_adap-&gt;retries;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; I2C_M_TEN) &#123;</span><br><span class="line">		<span class="comment">/* a ten bit address */</span></span><br><span class="line">		addr = <span class="number">0xf0</span> | ((msg-&gt;addr &gt;&gt; <span class="number">7</span>) &amp; <span class="number">0x06</span>);</span><br><span class="line">		bit_dbg(<span class="number">2</span>, &amp;i2c_adap-&gt;dev, <span class="string">"addr0: %d\n"</span>, addr);</span><br><span class="line">		<span class="comment">/* try extended address code...*/</span></span><br><span class="line">		ret = try_address(i2c_adap, addr, retries);</span><br><span class="line">		<span class="keyword">if</span> ((ret != <span class="number">1</span>) &amp;&amp; !nak_ok)  &#123;</span><br><span class="line">			dev_err(&amp;i2c_adap-&gt;dev,</span><br><span class="line">				<span class="string">"died at extended address code\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -ENXIO;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* the remaining 8 bit address */</span></span><br><span class="line">		ret = i2c_outb(i2c_adap, msg-&gt;addr &amp; <span class="number">0xff</span>);</span><br><span class="line">		<span class="keyword">if</span> ((ret != <span class="number">1</span>) &amp;&amp; !nak_ok) &#123;</span><br><span class="line">			<span class="comment">/* the chip did not ack / xmission error occurred */</span></span><br><span class="line">			dev_err(&amp;i2c_adap-&gt;dev, <span class="string">"died at 2nd address code\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -ENXIO;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; I2C_M_RD) &#123;</span><br><span class="line">			bit_dbg(<span class="number">3</span>, &amp;i2c_adap-&gt;dev, <span class="string">"emitting repeated "</span></span><br><span class="line">				<span class="string">"start condition\n"</span>);</span><br><span class="line">			i2c_repstart(adap);</span><br><span class="line">			<span class="comment">/* okay, now switch into reading mode */</span></span><br><span class="line">			addr |= <span class="number">0x01</span>;</span><br><span class="line">			ret = try_address(i2c_adap, addr, retries);</span><br><span class="line">			<span class="keyword">if</span> ((ret != <span class="number">1</span>) &amp;&amp; !nak_ok) &#123;</span><br><span class="line">				dev_err(&amp;i2c_adap-&gt;dev,</span><br><span class="line">					<span class="string">"died at repeated address code\n"</span>);</span><br><span class="line">				<span class="keyword">return</span> -EIO;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;		<span class="comment">/* normal 7bit address	*/</span></span><br><span class="line">		addr = msg-&gt;addr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; I2C_M_RD)</span><br><span class="line">			addr |= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; I2C_M_REV_DIR_ADDR)</span><br><span class="line">			addr ^= <span class="number">1</span>;</span><br><span class="line">		ret = try_address(i2c_adap, addr, retries);</span><br><span class="line">		<span class="keyword">if</span> ((ret != <span class="number">1</span>) &amp;&amp; !nak_ok) &#123;</span><br><span class="line">			dev_err(&amp;i2c_adap-&gt;dev, <span class="string">"Error on address cycle\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> -ENXIO;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bit_doAddress()向i2c bus发送当前i2c message对应的address byte，该字节由address[7:0]与read/write bit构成</p>
<p>若数据发送成功同时接收到ack信号，则函数返回0，否则函数返回负的错误码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_address</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *i2c_adap,</span><br><span class="line">		       <span class="keyword">unsigned</span> <span class="keyword">char</span> addr, <span class="keyword">int</span> retries)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_algo_bit_data *adap = i2c_adap-&gt;algo_data;</span><br><span class="line">	<span class="keyword">int</span> i, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= retries; i++) &#123;</span><br><span class="line">		ret = i2c_outb(i2c_adap, addr);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">1</span> || i == retries)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		bit_dbg(<span class="number">3</span>, &amp;i2c_adap-&gt;dev, <span class="string">"emitting stop condition\n"</span>);</span><br><span class="line">		i2c_stop(adap);</span><br><span class="line">		udelay(adap-&gt;udelay);</span><br><span class="line">		<span class="keyword">if</span> (!i2c_adap-&gt;atomic_xfer_only)</span><br><span class="line">			cond_resched();</span><br><span class="line">		bit_dbg(<span class="number">3</span>, &amp;i2c_adap-&gt;dev, <span class="string">"emitting start condition\n"</span>);</span><br><span class="line">		i2c_start(adap);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i &amp;&amp; ret)</span><br><span class="line">		bit_dbg(<span class="number">1</span>, &amp;i2c_adap-&gt;dev, <span class="string">"Used %d tries to %s client at "</span></span><br><span class="line">			<span class="string">"0x%02x: %s\n"</span>, i + <span class="number">1</span>,</span><br><span class="line">			addr &amp; <span class="number">1</span> ? <span class="string">"read from"</span> : <span class="string">"write to"</span>, addr &gt;&gt; <span class="number">1</span>,</span><br><span class="line">			ret == <span class="number">1</span> ? <span class="string">"success"</span> : <span class="string">"failed, timeout?"</span>);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>try_address()向i2c bus发送 address byte，该字节由address[7:0]与read/write bit构成</p>
<p>addr参数为需要发送的address byte，retries参数表示重试次数，即当数据发送失败时可以再次尝试发送</p>
<p>若address byte发送失败则函数返回负的错误码，否则若收到ack信号则返回1，否则返回0</p>
<h5 id="readbytes"><a href="#readbytes" class="headerlink" title="readbytes"></a>readbytes</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readbytes</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *i2c_adap, <span class="keyword">struct</span> i2c_msg *msg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> inval;</span><br><span class="line">	<span class="keyword">int</span> rdcount = <span class="number">0</span>;	<span class="comment">/* counts bytes read */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *temp = msg-&gt;buf;</span><br><span class="line">	<span class="keyword">int</span> count = msg-&gt;len;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> flags = msg-&gt;flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		inval = i2c_inb(i2c_adap);</span><br><span class="line">		<span class="keyword">if</span> (inval &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			*temp = inval;</span><br><span class="line">			rdcount++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;   <span class="comment">/* read timed out */</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		temp++;</span><br><span class="line">		count--;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Some SMBus transactions require that we receive the</span><br><span class="line">		   transaction length as the first read byte. */</span></span><br><span class="line">		<span class="keyword">if</span> (rdcount == <span class="number">1</span> &amp;&amp; (flags &amp; I2C_M_RECV_LEN)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (inval &lt;= <span class="number">0</span> || inval &gt; I2C_SMBUS_BLOCK_MAX) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!(flags &amp; I2C_M_NO_RD_ACK))</span><br><span class="line">					acknak(i2c_adap, <span class="number">0</span>);</span><br><span class="line">				dev_err(&amp;i2c_adap-&gt;dev, <span class="string">"readbytes: invalid "</span></span><br><span class="line">					<span class="string">"block length (%d)\n"</span>, inval);</span><br><span class="line">				<span class="keyword">return</span> -EPROTO;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* The original count value accounts for the extra</span><br><span class="line">			   bytes, that is, either 1 for a regular transaction,</span><br><span class="line">			   or 2 for a PEC transaction. */</span></span><br><span class="line">			count += inval;</span><br><span class="line">			msg-&gt;len += inval;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		bit_dbg(<span class="number">2</span>, &amp;i2c_adap-&gt;dev, <span class="string">"readbytes: 0x%02x %s\n"</span>,</span><br><span class="line">			inval,</span><br><span class="line">			(flags &amp; I2C_M_NO_RD_ACK)</span><br><span class="line">				? <span class="string">"(no ack/nak)"</span></span><br><span class="line">				: (count ? <span class="string">"A"</span> : <span class="string">"NA"</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; I2C_M_NO_RD_ACK)) &#123;</span><br><span class="line">			inval = acknak(i2c_adap, count);</span><br><span class="line">			<span class="keyword">if</span> (inval &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> inval;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rdcount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>readbytes()向i2c bus传输一个i2c message，操作类型为读操作</p>
<p>函数返回成功读取的数据的字节数</p>
<h5 id="sendbytes"><a href="#sendbytes" class="headerlink" title="sendbytes"></a>sendbytes</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sendbytes</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *i2c_adap, <span class="keyword">struct</span> i2c_msg *msg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *temp = msg-&gt;buf;</span><br><span class="line">	<span class="keyword">int</span> count = msg-&gt;len;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> nak_ok = msg-&gt;flags &amp; I2C_M_IGNORE_NAK;</span><br><span class="line">	<span class="keyword">int</span> retval;</span><br><span class="line">	<span class="keyword">int</span> wrcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		retval = i2c_outb(i2c_adap, *temp);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* OK/ACK; or ignored NAK */</span></span><br><span class="line">		<span class="keyword">if</span> ((retval &gt; <span class="number">0</span>) || (nak_ok &amp;&amp; (retval == <span class="number">0</span>)) || (count == <span class="number">1</span>)) &#123;</span><br><span class="line">			count--;</span><br><span class="line">			temp++;</span><br><span class="line">			wrcount++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* A slave NAKing the master means the slave didn't like</span><br><span class="line">		 * something about the data it saw.  For example, maybe</span><br><span class="line">		 * the SMBus PEC was wrong.</span><br><span class="line">		 */</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">			dev_err(&amp;i2c_adap-&gt;dev,</span><br><span class="line">				<span class="string">"sendbytes: NAK bailout on byte %d\n"</span>, count);</span><br><span class="line">			<span class="keyword">return</span> -EIO;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Timeout; or (someday) lost arbitration</span><br><span class="line">		 *</span><br><span class="line">		 * FIXME Lost ARB implies retrying the transaction from</span><br><span class="line">		 * the first message, after the "winning" master issues</span><br><span class="line">		 * its STOP.  As a rule, upper layer code has no reason</span><br><span class="line">		 * to know or care about this ... it is *NOT* an error.</span><br><span class="line">		 */</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dev_err(&amp;i2c_adap-&gt;dev,</span><br><span class="line">				<span class="string">"sendbytes: error %d on byte %d\n"</span>,</span><br><span class="line">				retval, count);</span><br><span class="line">			<span class="keyword">return</span> retval;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> wrcount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendbytes()向i2c bus传输一个i2c message，操作类型为写操作</p>
<p>函数返回成功写入的数据的字节数</p>
<h4 id="Algorithm-Core"><a href="#Algorithm-Core" class="headerlink" title="Algorithm Core"></a>Algorithm Core</h4><h5 id="i2c-bit-algo"><a href="#i2c-bit-algo" class="headerlink" title="i2c_bit_algo"></a>i2c_bit_algo</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> i2c_algorithm i2c_bit_algo = &#123;</span><br><span class="line">	.master_xfer	= bit_xfer,</span><br><span class="line">	.functionality	= bit_func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>bit-banging algorithm 只支持standard I2C protocol，而不支持SMBus protocol</p>
<h5 id="bit-func"><a href="#bit-func" class="headerlink" title="bit_func"></a>bit_func</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">bit_func</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> I2C_FUNC_I2C | I2C_FUNC_NOSTART | I2C_FUNC_SMBUS_EMUL |</span><br><span class="line">	       I2C_FUNC_SMBUS_READ_BLOCK_DATA |</span><br><span class="line">	       I2C_FUNC_SMBUS_BLOCK_PROC_CALL |</span><br><span class="line">	       I2C_FUNC_10BIT_ADDR | I2C_FUNC_PROTOCOL_MANGLING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bit-banging algorithm的functionality()回调函数为bit_func()</p>
<p>bit-banging algorithm 支持standard I2C、10 bit address等功能</p>
<h5 id="bit-xfer"><a href="#bit-xfer" class="headerlink" title="bit_xfer"></a>bit_xfer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bit_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *i2c_adap,</span><br><span class="line">		    <span class="keyword">struct</span> i2c_msg msgs[], <span class="keyword">int</span> num)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_msg *pmsg;</span><br><span class="line">	<span class="keyword">struct</span> i2c_algo_bit_data *adap = i2c_adap-&gt;algo_data;</span><br><span class="line">	<span class="keyword">int</span> i, ret;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> nak_ok;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;pre_xfer) &#123;</span><br><span class="line">		ret = adap-&gt;pre_xfer(i2c_adap);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bit_dbg(<span class="number">3</span>, &amp;i2c_adap-&gt;dev, <span class="string">"emitting start condition\n"</span>);</span><br><span class="line">	i2c_start(adap);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">		pmsg = &amp;msgs[i];</span><br><span class="line">		nak_ok = pmsg-&gt;flags &amp; I2C_M_IGNORE_NAK;</span><br><span class="line">		<span class="keyword">if</span> (!(pmsg-&gt;flags &amp; I2C_M_NOSTART)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i) &#123;</span><br><span class="line">				bit_dbg(<span class="number">3</span>, &amp;i2c_adap-&gt;dev, <span class="string">"emitting "</span></span><br><span class="line">					<span class="string">"repeated start condition\n"</span>);</span><br><span class="line">				i2c_repstart(adap);</span><br><span class="line">			&#125;</span><br><span class="line">			ret = bit_doAddress(i2c_adap, pmsg);</span><br><span class="line">			<span class="keyword">if</span> ((ret != <span class="number">0</span>) &amp;&amp; !nak_ok) &#123;</span><br><span class="line">				bit_dbg(<span class="number">1</span>, &amp;i2c_adap-&gt;dev, <span class="string">"NAK from "</span></span><br><span class="line">					<span class="string">"device addr 0x%02x msg #%d\n"</span>,</span><br><span class="line">					msgs[i].addr, i);</span><br><span class="line">				<span class="keyword">goto</span> bailout;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pmsg-&gt;flags &amp; I2C_M_RD) &#123;</span><br><span class="line">			<span class="comment">/* read bytes into buffer*/</span></span><br><span class="line">			ret = readbytes(i2c_adap, pmsg);</span><br><span class="line">			<span class="keyword">if</span> (ret &gt;= <span class="number">1</span>)</span><br><span class="line">				bit_dbg(<span class="number">2</span>, &amp;i2c_adap-&gt;dev, <span class="string">"read %d byte%s\n"</span>,</span><br><span class="line">					ret, ret == <span class="number">1</span> ? <span class="string">""</span> : <span class="string">"s"</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; pmsg-&gt;len) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">					ret = -EIO;</span><br><span class="line">				<span class="keyword">goto</span> bailout;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* write bytes from buffer */</span></span><br><span class="line">			ret = sendbytes(i2c_adap, pmsg);</span><br><span class="line">			<span class="keyword">if</span> (ret &gt;= <span class="number">1</span>)</span><br><span class="line">				bit_dbg(<span class="number">2</span>, &amp;i2c_adap-&gt;dev, <span class="string">"wrote %d byte%s\n"</span>,</span><br><span class="line">					ret, ret == <span class="number">1</span> ? <span class="string">""</span> : <span class="string">"s"</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; pmsg-&gt;len) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">					ret = -EIO;</span><br><span class="line">				<span class="keyword">goto</span> bailout;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = i;</span><br><span class="line"></span><br><span class="line">bailout:</span><br><span class="line">	bit_dbg(<span class="number">3</span>, &amp;i2c_adap-&gt;dev, <span class="string">"emitting stop condition\n"</span>);</span><br><span class="line">	i2c_stop(adap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;post_xfer)</span><br><span class="line">		adap-&gt;post_xfer(i2c_adap);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bit-banging algorithm的master_xfer()回调函数为bit_xfer()</p>
<ul>
<li>若i2c_algo_bit_data的pre_xfer()回调函数存在定义，则调用该回调函数执行一些数据传输前的准备工作</li>
<li>调用i2c_start()产生开始信号S</li>
<li>传输i2c message，对于需要传输的每个i2c message<ul>
<li>调用bit_doAddress()发送address byte</li>
<li>若当前i2c message为读操作，则调用readbytes()读取数据并保存在i2c message中，否则调用sendbytes()发送数据</li>
</ul>
</li>
<li>调用i2c_stop()产生结束信号P</li>
<li>若i2c_algo_bit_data的post_xfer()回调函数存在定义，则调用该回调函数执行一些数据传输后的清理工作</li>
</ul>
<h5 id="i2c-bit-add-bus"><a href="#i2c-bit-add-bus" class="headerlink" title="i2c_bit_add_bus"></a>i2c_bit_add_bus</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_bit_add_bus</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __i2c_bit_add_bus(adap, i2c_add_adapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_bit_add_bus()注册一个使用bit-banging algorithm的i2c adapter，该adapetr的bus ID由i2c core动态分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __i2c_bit_add_bus(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">			     <span class="keyword">int</span> (*add_adapter)(<span class="keyword">struct</span> i2c_adapter *))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_algo_bit_data *bit_adap = adap-&gt;algo_data;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bit_test) &#123;</span><br><span class="line">		ret = test_bus(adap);</span><br><span class="line">		<span class="keyword">if</span> (bit_test &gt;= <span class="number">2</span> &amp;&amp; ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* register new adapter to i2c module... */</span></span><br><span class="line">	adap-&gt;algo = &amp;i2c_bit_algo;</span><br><span class="line">	adap-&gt;retries = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	ret = add_adapter(adap);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Complain if SCL can't be read */</span></span><br><span class="line">	<span class="keyword">if</span> (bit_adap-&gt;getscl == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		dev_warn(&amp;adap-&gt;dev, <span class="string">"Not I2C compliant: can't read SCL\n"</span>);</span><br><span class="line">		dev_warn(&amp;adap-&gt;dev, <span class="string">"Bus may be unreliable\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="i2c-bit-add-numbered-bus"><a href="#i2c-bit-add-numbered-bus" class="headerlink" title="i2c_bit_add_numbered_bus"></a>i2c_bit_add_numbered_bus</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i2c_bit_add_numbered_bus</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> __i2c_bit_add_bus(adap, i2c_add_numbered_adapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_bit_add_bus()注册一个使用bit-banging algorithm的i2c adapter，该adapetr的bus ID由该adapter的nr成员指定</p>
<h3 id="I2C-Mux"><a href="#I2C-Mux" class="headerlink" title="I2C Mux"></a>I2C Mux</h3><p>当系统中存在一个I2C controller以及一个I2C multiplexer时，I2C Multiplexing允许将一个I2C controller划分为多个multiplexed segment，每个segment都可以视为一个independent i2c adapter</p>
<p>例如下图中存在i2c-0 adapter、i2c-1 adapter以及i2c-2 adapter</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+------------+   segment <span class="number">0</span> (i2c<span class="number">-0</span>)</span><br><span class="line">| controller |-------+--------+----------+---</span><br><span class="line">+------------+       |        |          |</span><br><span class="line">                     |        |          |</span><br><span class="line">                     |    +-------+  +-------+</span><br><span class="line">                     |    | dev A |  | dev B |</span><br><span class="line">                     |    +-------+  +-------+</span><br><span class="line">                     |</span><br><span class="line">                     |                    +-------+  +-------+</span><br><span class="line">                     |                    | dev C |  | dev D |</span><br><span class="line">                     |                    +-------+  +-------+</span><br><span class="line">                     |                        |          |</span><br><span class="line">                  +-----+   segment <span class="number">1</span> (i2c<span class="number">-1</span>) |          |</span><br><span class="line">                  |     |---------------------+---       |</span><br><span class="line">                  | MUX |                                |</span><br><span class="line">                  |     |--------------------------------+---</span><br><span class="line">                  +-----+   segment <span class="number">2</span> (i2c<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<p><code>include/linux/i2c-mux.h</code>与<code>drivers/i2c/i2c-mux.c</code>中定义 I2C Mux 的数据结构与操作函数<br><code>drivers/i2c/mux/</code>下为i2c multiplexer chip driver</p>
<h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="i2c-mux-priv"><a href="#i2c-mux-priv" class="headerlink" title="i2c_mux_priv"></a>i2c_mux_priv</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_mux_priv &#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter adap;</span><br><span class="line">	<span class="keyword">struct</span> i2c_algorithm algo;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *parent;</span><br><span class="line">	<span class="keyword">void</span> *mux_priv;	<span class="comment">/* the mux chip/device */</span></span><br><span class="line">	u32  chan_id;	<span class="comment">/* the channel id */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> (*select)(<span class="keyword">struct</span> i2c_adapter *, <span class="keyword">void</span> *mux_priv, u32 chan_id);</span><br><span class="line">	<span class="keyword">int</span> (*deselect)(<span class="keyword">struct</span> i2c_adapter *, <span class="keyword">void</span> *mux_priv, u32 chan_id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct i2c_mux_priv抽象i2c mux segment，即为每个i2c mux channel维护一个i2c_mux_priv结构</p>
<p>@adap       该i2c mux segment对应的i2c adapter，每个i2c mux segment都可以视为一个independent i2c adapter<br>@algo       该i2c mux segment对应的i2c adapter的algorithm<br>@parent     与该i2c multiplexer相连接的i2c controller<br>@mux_priv   该i2c mux channel所属的i2c multiplexer<br>@chan_id    该i2c mux channel ID<br>@select     用于特定i2c mux channel path的导通<br>@deselect   用于特定i2c mux channel path的关闭</p>
<h4 id="I2C-mux-core"><a href="#I2C-mux-core" class="headerlink" title="I2C mux core"></a>I2C mux core</h4><h5 id="i2c-add-mux-adapter"><a href="#i2c-add-mux-adapter" class="headerlink" title="i2c_add_mux_adapter"></a>i2c_add_mux_adapter</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">struct i2c_adapter *i2c_add_mux_adapter(struct i2c_adapter *parent,</span><br><span class="line">				struct device *mux_dev,</span><br><span class="line">				void *mux_priv, u32 force_nr, u32 chan_id,</span><br><span class="line">				unsigned int class,</span><br><span class="line">				int (*select) (struct i2c_adapter *,</span><br><span class="line">					       void *, u32),</span><br><span class="line">				int (*deselect) (struct i2c_adapter *,</span><br><span class="line">						 void *, u32))</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_mux_priv *priv;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	priv = kzalloc(sizeof(struct i2c_mux_priv), GFP_KERNEL);</span><br><span class="line">	if (!priv)</span><br><span class="line">		return NULL;</span><br><span class="line"></span><br><span class="line">	/* Set up private adapter data */</span><br><span class="line">	priv-&gt;parent = parent;</span><br><span class="line">	priv-&gt;mux_priv = mux_priv;</span><br><span class="line">	priv-&gt;chan_id = chan_id;</span><br><span class="line">	priv-&gt;select = select;</span><br><span class="line"></span><br><span class="line">	/* Need to do algo dynamically because we don't know ahead</span><br><span class="line">	 * of time what sort of physical adapter we'll be dealing with.</span><br><span class="line">	 */</span><br><span class="line">	if (parent-&gt;algo-&gt;master_xfer)</span><br><span class="line">		priv-&gt;algo.master_xfer = i2c_mux_master_xfer;</span><br><span class="line">	if (parent-&gt;algo-&gt;smbus_xfer)</span><br><span class="line">		priv-&gt;algo.smbus_xfer = i2c_mux_smbus_xfer;</span><br><span class="line">	priv-&gt;algo.functionality = i2c_mux_functionality;</span><br><span class="line"></span><br><span class="line">	/* Now fill out new adapter structure */</span><br><span class="line">	snprintf(priv-&gt;adap.name, sizeof(priv-&gt;adap.name),</span><br><span class="line">		 "i2c-%d-mux (chan_id %d)", i2c_adapter_id(parent), chan_id);</span><br><span class="line">	priv-&gt;adap.owner = THIS_MODULE;</span><br><span class="line">	priv-&gt;adap.algo = &amp;priv-&gt;algo;</span><br><span class="line">	priv-&gt;adap.algo_data = priv;</span><br><span class="line">	priv-&gt;adap.dev.parent = &amp;parent-&gt;dev;</span><br><span class="line"></span><br><span class="line">	/* Sanity check on class */</span><br><span class="line">	if (i2c_mux_parent_classes(parent) &amp; class)</span><br><span class="line">		dev_err(&amp;parent-&gt;dev,</span><br><span class="line">			"Segment %d behind mux can't share classes with ancestors\n",</span><br><span class="line">			chan_id);</span><br><span class="line">	else</span><br><span class="line">		priv-&gt;adap.class = class;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Try to populate the mux adapter's of_node, expands to</span><br><span class="line">	 * nothing if !CONFIG_OF.</span><br><span class="line">	 */</span><br><span class="line">	if (mux_dev-&gt;of_node) &#123;</span><br><span class="line">		struct device_node *child;</span><br><span class="line">		bool enable_deselect;</span><br><span class="line">		u32 reg;</span><br><span class="line"></span><br><span class="line">		for_each_child_of_node(mux_dev-&gt;of_node, child) &#123;</span><br><span class="line">			ret = of_property_read_u32(child, "reg", &amp;reg);</span><br><span class="line">			if (ret)</span><br><span class="line">				continue;</span><br><span class="line">			if (chan_id == reg) &#123;</span><br><span class="line">				priv-&gt;adap.dev.of_node = child;</span><br><span class="line">				enable_deselect = of_property_read_bool(child,</span><br><span class="line">						"i2c-mux,deselect-on-exit");</span><br><span class="line">				if (enable_deselect) </span><br><span class="line">					priv-&gt;deselect = deselect;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		priv-&gt;deselect = deselect;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (force_nr) &#123;</span><br><span class="line">		priv-&gt;adap.nr = force_nr;</span><br><span class="line">		ret = i2c_add_numbered_adapter(&amp;priv-&gt;adap);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		ret = i2c_add_adapter(&amp;priv-&gt;adap);</span><br><span class="line">	&#125;</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		dev_err(&amp;parent-&gt;dev,</span><br><span class="line">			"failed to add mux-adapter (error=%d)\n",</span><br><span class="line">			ret);</span><br><span class="line">		kfree(priv);</span><br><span class="line">		return NULL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev_info(&amp;parent-&gt;dev, "Added multiplexed i2c bus %d\n",</span><br><span class="line">		 i2c_adapter_id(&amp;priv-&gt;adap));</span><br><span class="line"></span><br><span class="line">	of_i2c_register_devices(&amp;priv-&gt;adap);</span><br><span class="line"></span><br><span class="line">	return &amp;priv-&gt;adap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_add_mux_adapter()注册该i2c mux channel对应的i2c adapter</p>
<p>@parent         与该i2c multiplexer相连接的i2c controller<br>@mux_dev        该i2c mux channel所属的i2c multiplexer的device结构<br>@mux_priv       该i2c mux channel所属的i2c multiplexer<br>@force_nr       指定该i2c mux channel对应的i2c adapter的bus number，若该参数为0则为该i2c adapter动态分配bus number<br>@chan_id        该i2c mux channel ID<br>@class          该i2c mux channel对应的i2c adapter的class，描述其对应的i2c adapter支持的slave device的类型<br>@select/deselect</p>
<p>成功返回该i2c mux channel对应的i2c adapter，否则返回NULL</p>
<ul>
<li>根据传入的参数创建并初始化该i2c mux channel对应的i2c_mux_priv结构</li>
<li>调用i2c_add_adapter()或i2c_add_numbered_adapter()注册该i2c mux channel对应的i2c adapter</li>
<li>调用of_i2c_register_devices()注册在设备树中定义的该i2c mux channel下的所有i2c client</li>
</ul>
<h5 id="i2c-del-mux-adapter"><a href="#i2c-del-mux-adapter" class="headerlink" title="i2c_del_mux_adapter"></a>i2c_del_mux_adapter</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_del_mux_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_mux_priv *priv = adap-&gt;algo_data;</span><br><span class="line"></span><br><span class="line">	i2c_del_adapter(adap);</span><br><span class="line">	kfree(priv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_del_mux_adapter()注销i2c mux channel对应的i2c adapter</p>
<h5 id="i2c-mux-functionality"><a href="#i2c-mux-functionality" class="headerlink" title="i2c_mux_functionality"></a>i2c_mux_functionality</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">i2c_mux_functionality</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_mux_priv *priv = adap-&gt;algo_data;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *parent = priv-&gt;parent;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> parent-&gt;algo-&gt;functionality(parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c mux channel对应的i2c adapter的algorithm的functionality()回调函数为i2c_mux_functionality()，该函数实际调用该i2c multiplexer连接的i2c controller对应的i2c adapter的functionality()回调函数</p>
<h5 id="i2c-mux-master-xfer"><a href="#i2c-mux-master-xfer" class="headerlink" title="i2c_mux_master_xfer"></a>i2c_mux_master_xfer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_mux_master_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">			       <span class="keyword">struct</span> i2c_msg msgs[], <span class="keyword">int</span> num)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_mux_priv *priv = adap-&gt;algo_data;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *parent = priv-&gt;parent;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Switch to the right mux port and perform the transfer. */</span></span><br><span class="line"></span><br><span class="line">	ret = priv-&gt;select(parent, priv-&gt;mux_priv, priv-&gt;chan_id);</span><br><span class="line">	<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">		ret = parent-&gt;algo-&gt;master_xfer(parent, msgs, num);</span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;deselect)</span><br><span class="line">		priv-&gt;deselect(parent, priv-&gt;mux_priv, priv-&gt;chan_id);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当parent i2c controller对应的i2c adapter的master_xfer()回调函数存在定义时，i2c mux channel对应的i2c adapter的master_xfer()回调函数为i2c_mux_master_xfer()</p>
<ul>
<li>调用该i2c mux channel的select()回调函数实现该i2c mux channel path的导通</li>
<li>调用parent i2c controller对应的i2c adapter的master_xfer()回调函数实现真正的数据传输</li>
<li>若该i2c mux channel的deselect()回调函数存在定义，则调用该回调函数实现该i2c mux channel path的关闭</li>
</ul>
<h5 id="i2c-mux-smbus-xfer"><a href="#i2c-mux-smbus-xfer" class="headerlink" title="i2c_mux_smbus_xfer"></a>i2c_mux_smbus_xfer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2c_mux_smbus_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">			      u16 addr, <span class="keyword">unsigned</span> <span class="keyword">short</span> flags,</span><br><span class="line">			      <span class="keyword">char</span> read_write, u8 command,</span><br><span class="line">			      <span class="keyword">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_mux_priv *priv = adap-&gt;algo_data;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *parent = priv-&gt;parent;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Select the right mux port and perform the transfer. */</span></span><br><span class="line"></span><br><span class="line">	ret = priv-&gt;select(parent, priv-&gt;mux_priv, priv-&gt;chan_id);</span><br><span class="line">	<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">		ret = parent-&gt;algo-&gt;smbus_xfer(parent, addr, flags,</span><br><span class="line">					read_write, command, size, data);</span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;deselect)</span><br><span class="line">		priv-&gt;deselect(parent, priv-&gt;mux_priv, priv-&gt;chan_id);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当parent i2c controller对应的i2c adapter的smbus_xfer()回调函数存在定义时，i2c mux channel对应的i2c adapter的master_xfer()回调函数为i2c_mux_smbus_xfer()</p>
<ul>
<li>调用该i2c mux channel的select()回调函数实现该i2c mux channel path的导通</li>
<li>调用parent i2c controller对应的i2c adapter的smbus_xfer()回调函数实现真正的数据传输</li>
<li>若该i2c mux channel的deselect()回调函数存在定义，则调用该回调函数实现该i2c mux channel path的关闭</li>
</ul>
<h3 id="i2cdev"><a href="#i2cdev" class="headerlink" title="i2cdev"></a>i2cdev</h3><p><code>include/linux/i2c-dev.h</code>、<code>include/uapi/linux/i2c-dev.h</code>与<code>drivers/i2c/i2c-dev.c</code>中定义i2cdev</p>
<p>通常用户态程序通过i2c protocol driver即i2c client driver实现与特定i2c client的数据传输，i2cdev core提供I2C bus interface，通过i2c adapter的设备的设备节点实现用户态程序与该i2c adapter下的特定i2c device的数据传输</p>
<h4 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="i2c-dev"><a href="#i2c-dev" class="headerlink" title="i2c_dev"></a>i2c_dev</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_dev &#123;</span><br><span class="line">	<span class="keyword">struct</span> list_head <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *adap;</span><br><span class="line">	<span class="keyword">struct</span> device *dev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct i2c_dev抽象i2cdev，每个i2cdev对应一个i2c adapter的设备文件</p>
<p>@list       通过该链表头将该i2cdev添加到i2c_dev_list全局链表中<br>@adap       该i2cdev对应的i2c adapter<br>@dev        用于创建该i2cdev对应的设备节点所需的device结构</p>
<h5 id="i2c-rdwr-ioctl-data"><a href="#i2c-rdwr-ioctl-data" class="headerlink" title="i2c_rdwr_ioctl_data"></a>i2c_rdwr_ioctl_data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_rdwr_ioctl_data &#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_msg __user *msgs;   <span class="comment">/* pointers to i2c_msgs */</span></span><br><span class="line">	__u32 nmsgs;			<span class="comment">/* number of i2c_msgs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct i2c_rdwr_ioctl_data抽象i2cdev中I2C protocol数据传输的相关数据结构</p>
<p>@msgs       需要传输的i2c message数组，其中i2c message中传输的数据的大小限制为8192个字节<br>@nmsgs      需要传输的i2c message的数量，最大为I2C_RDRW_IOCTL_MAX_MSGS，即42</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  I2C_RDRW_IOCTL_MAX_MSGS    42</span></span><br></pre></td></tr></table></figure>
<h5 id="i2c-smbus-ioctl-data"><a href="#i2c-smbus-ioctl-data" class="headerlink" title="i2c_smbus_ioctl_data"></a>i2c_smbus_ioctl_data</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_smbus_ioctl_data &#123;</span><br><span class="line">	__u8 read_write;</span><br><span class="line">	__u8 command;</span><br><span class="line">	__u32 size;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data __user *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>struct i2c_smbus_ioctl_data抽象i2cdev中SMBus protocol数据传输的相关数据结构</p>
<p>@read_write 数据发送或接收的标志位，I2C_SMBUS_READ or I2C_SMBUS_WRITE<br>@command    通常表示slave device需要读取或写入的寄存器地址<br>@size       通常表示传输的数据的大小，即需要执行的SMBus protocol operation的类型，如I2C_SMBUS_BYTE_DATA等<br>@data       需要传输的数据，SMBus protocol数据传输以i2c_smbus_data为单位</p>
<h5 id="device-number"><a href="#device-number" class="headerlink" title="device number"></a>device number</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_MAJOR	89		<span class="comment">/* Device major number */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I2C_MINORS	256</span></span><br></pre></td></tr></table></figure>
<p>创建的设备节点对应的cdev的主设备号为89，从设备号为i2c adapter的bus number，共支持256个从设备号</p>
<h5 id="i2c-dev-list-链表"><a href="#i2c-dev-list-链表" class="headerlink" title="i2c_dev_list 链表"></a>i2c_dev_list 链表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(i2c_dev_list)</span></span>;</span><br></pre></td></tr></table></figure>
<p>i2cdev core定义i2c_dev_list全局链表，用于管理所有的i2cdev</p>
<h5 id="i2c-dev-class"><a href="#i2c-dev-class" class="headerlink" title="i2c_dev_class"></a>i2c_dev_class</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> <span class="keyword">class</span> *i2c_dev_class;</span><br></pre></td></tr></table></figure>
<p>当使用mdev/udev创建相应的设备节点时，必须调用device_create()/device_add()，而同时device_create()/device_add()需要传入device的class参数，因而必须创建相应的class，i2cdev中定义i2cdev class</p>
<h4 id="i2cdev-core-init"><a href="#i2cdev-core-init" class="headerlink" title="i2cdev core init"></a>i2cdev core init</h4><h5 id="i2c-dev-init"><a href="#i2c-dev-init" class="headerlink" title="i2c_dev_init"></a>i2c_dev_init</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">i2c_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">"i2c /dev entries driver\n"</span>);</span><br><span class="line"></span><br><span class="line">	res = register_chrdev(I2C_MAJOR, <span class="string">"i2c"</span>, &amp;i2cdev_fops);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	i2c_dev_class = class_create(THIS_MODULE, <span class="string">"i2c-dev"</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(i2c_dev_class)) &#123;</span><br><span class="line">		res = PTR_ERR(i2c_dev_class);</span><br><span class="line">		<span class="keyword">goto</span> out_unreg_chrdev;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Keep track of adapters which will be added or removed later */</span></span><br><span class="line">	res = bus_register_notifier(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> out_unreg_class;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bind to already existing adapters right away */</span></span><br><span class="line">	i2c_for_each_dev(<span class="literal">NULL</span>, i2cdev_attach_adapter);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unreg_class:</span><br><span class="line">	class_destroy(i2c_dev_class);</span><br><span class="line">out_unreg_chrdev:</span><br><span class="line">	unregister_chrdev(I2C_MAJOR, <span class="string">"i2c"</span>);</span><br><span class="line">out:</span><br><span class="line">	printk(KERN_ERR <span class="string">"%s: Driver Initialisation failed\n"</span>, __FILE__);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_dev_init()完成i2cdev core的初始化</p>
<ul>
<li>注册i2cdev对应的cdev，其名称为”i2c”，主设备号为I2C_MAJOR，对应的file_operations结构为i2cdev_fops</li>
<li>注册i2cdev对应的device class，名称为”i2c-dev”</li>
<li>调用bus_register_notifier()向i2c bus注册i2cdev_notifier</li>
<li>遍历当前注册的所有i2c adapter，对每个i2c adapter调用i2cdev_attach_adapter()以实现i2cdev与对应的i2c adapter的binding</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2cdev_attach_adapter</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">void</span> *dummy)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *adap;</span><br><span class="line">	<span class="keyword">struct</span> i2c_dev *i2c_dev;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;type != &amp;i2c_adapter_type)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	adap = to_i2c_adapter(dev);</span><br><span class="line"></span><br><span class="line">	i2c_dev = get_free_i2c_dev(adap);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(i2c_dev))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(i2c_dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* register this i2c device with the driver core */</span></span><br><span class="line">	i2c_dev-&gt;dev = device_create(i2c_dev_class, &amp;adap-&gt;dev,</span><br><span class="line">				     MKDEV(I2C_MAJOR, adap-&gt;nr), <span class="literal">NULL</span>,</span><br><span class="line">				     <span class="string">"i2c-%d"</span>, adap-&gt;nr);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(i2c_dev-&gt;dev)) &#123;</span><br><span class="line">		res = PTR_ERR(i2c_dev-&gt;dev);</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">	res = device_create_file(i2c_dev-&gt;dev, &amp;dev_attr_name);</span><br><span class="line">	<span class="keyword">if</span> (res)</span><br><span class="line">		<span class="keyword">goto</span> error_destroy;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">"i2c-dev: adapter [%s] registered as minor %d\n"</span>,</span><br><span class="line">		 adap-&gt;name, adap-&gt;nr);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">error_destroy:</span><br><span class="line">	device_destroy(i2c_dev_class, MKDEV(I2C_MAJOR, adap-&gt;nr));</span><br><span class="line">error:</span><br><span class="line">	return_i2c_dev(i2c_dev);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2cdev_attach_adapter()以实现i2cdev与对应的i2c adapter的binding</p>
<ul>
<li>对于当前遍历的i2c adapter，调用get_free_i2c_dev()创建并初始化该i2c adapter对应的i2cdev</li>
<li>调用device_create()创建该i2cdev的device结构，该device的class为i2c_dev_class，其parent device为对应的i2c adapter的device结构，device的driver data为该i2c adapter的bus number，device的名称为”i2c-<bus_number>“</bus_number></li>
<li>若对应的device创建成功，则在该device对应的sysfs目录下创建dev_attr_name属性文件，即name属性文件，显示该i2c adapter的名称</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> i2c_dev *<span class="title">get_free_i2c_dev</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_dev *i2c_dev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (adap-&gt;nr &gt;= I2C_MINORS) &#123;</span><br><span class="line">		printk(KERN_ERR <span class="string">"i2c-dev: Out of device minors (%d)\n"</span>,</span><br><span class="line">		       adap-&gt;nr);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i2c_dev = kzalloc(<span class="keyword">sizeof</span>(*i2c_dev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!i2c_dev)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	i2c_dev-&gt;adap = adap;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;i2c_dev_list_lock);</span><br><span class="line">	list_add_tail(&amp;i2c_dev-&gt;<span class="built_in">list</span>, &amp;i2c_dev_list);</span><br><span class="line">	spin_unlock(&amp;i2c_dev_list_lock);</span><br><span class="line">	<span class="keyword">return</span> i2c_dev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get_free_i2c_dev()创建并初始化该i2c adapter对应的i2cdev，设置其adap成员为传入的i2c adapter，并将创建的i2cdev添加到i2c_dev_list全局链表中</p>
<p>当向i2c bus添加或移除i2c adapter时，都将调用i2cdev_notifier的notifier_call()回调函数，即i2cdev_notifier_call()以实现i2c adapter与i2cdev的binding/unbinding</p>
<h5 id="i2cdev-notifier"><a href="#i2cdev-notifier" class="headerlink" title="i2cdev_notifier"></a>i2cdev_notifier</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> notifier_block i2cdev_notifier = &#123;</span><br><span class="line">	.notifier_call = i2cdev_notifier_call,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2cdev_notifier_call</span><span class="params">(<span class="keyword">struct</span> notifier_block *nb, <span class="keyword">unsigned</span> <span class="keyword">long</span> action,</span><br><span class="line">			 <span class="keyword">void</span> *data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> device *dev = data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (action) &#123;</span><br><span class="line">	<span class="keyword">case</span> BUS_NOTIFY_ADD_DEVICE:</span><br><span class="line">		<span class="keyword">return</span> i2cdev_attach_adapter(dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">case</span> BUS_NOTIFY_DEL_DEVICE:</span><br><span class="line">		<span class="keyword">return</span> i2cdev_detach_adapter(dev, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="i2cdev-core"><a href="#i2cdev-core" class="headerlink" title="i2cdev core"></a>i2cdev core</h4><h5 id="i2cdev-fops"><a href="#i2cdev-fops" class="headerlink" title="i2cdev_fops"></a>i2cdev_fops</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> file_operations i2cdev_fops = &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.llseek		= no_llseek,</span><br><span class="line">	.read		= i2cdev_read,</span><br><span class="line">	.write		= i2cdev_write,</span><br><span class="line">	.unlocked_ioctl	= i2cdev_ioctl,</span><br><span class="line">	.open		= i2cdev_open,</span><br><span class="line">	.release	= i2cdev_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>i2cdev对应的cdev的file_operations结构为i2cdev_fops</p>
<h5 id="i2cdev-open"><a href="#i2cdev-open" class="headerlink" title="i2cdev_open"></a>i2cdev_open</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">i2cdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> minor = iminor(inode);</span><br><span class="line">	<span class="keyword">struct</span> i2c_client *client;</span><br><span class="line">	<span class="keyword">struct</span> i2c_adapter *adap;</span><br><span class="line">	<span class="keyword">struct</span> i2c_dev *i2c_dev;</span><br><span class="line"></span><br><span class="line">	i2c_dev = i2c_dev_get_by_minor(minor);</span><br><span class="line">	<span class="keyword">if</span> (!i2c_dev)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	adap = i2c_get_adapter(i2c_dev-&gt;adap-&gt;nr);</span><br><span class="line">	<span class="keyword">if</span> (!adap)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This creates an anonymous i2c_client, which may later be</span><br><span class="line">	 * pointed to some address using I2C_SLAVE or I2C_SLAVE_FORCE.</span><br><span class="line">	 *</span><br><span class="line">	 * This client is ** NEVER REGISTERED ** with the driver model</span><br><span class="line">	 * or I2C core code!!  It just holds private copies of addressing</span><br><span class="line">	 * information and maybe a PEC flag.</span><br><span class="line">	 */</span></span><br><span class="line">	client = kzalloc(<span class="keyword">sizeof</span>(*client), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!client) &#123;</span><br><span class="line">		i2c_put_adapter(adap);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">snprintf</span>(client-&gt;name, I2C_NAME_SIZE, <span class="string">"i2c-dev %d"</span>, adap-&gt;nr);</span><br><span class="line"></span><br><span class="line">	client-&gt;adapter = adap;</span><br><span class="line">	file-&gt;private_data = client;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当对设备节点进行open操作时，实际调用i2cdev_open()</p>
<ul>
<li>当打开设备文件时，inode-&gt;i_rdev记录了当前打开的设备节点对应的设备号，通过当前的设备号调用i2c_dev_get_by_minor()获取当前打开的设备文件对应的i2cdev</li>
<li>调用i2c_get_adapter()增加当前的i2cdev对应的i2c adapter的引用计数</li>
<li>创建一个anonymous i2c client，在之后的操作中该i2c client将被用于数据传输相关的操作</li>
<li>设置创建的i2c client的adapter成员为当前的i2c adapter，并将该i2c client赋值给file-&gt;private_data</li>
</ul>
<h5 id="i2cdev-read"><a href="#i2cdev-read" class="headerlink" title="i2cdev_read"></a>i2cdev_read</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">i2cdev_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">char</span> __user *buf, size_t count,</span><br><span class="line">		loff_t *offset)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *tmp;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> i2c_client *client = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count &gt; <span class="number">8192</span>)</span><br><span class="line">		count = <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line">	tmp = kmalloc(count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">"i2c-dev: i2c-%d reading %zu bytes.\n"</span>,</span><br><span class="line">		iminor(file_inode(file)), count);</span><br><span class="line"></span><br><span class="line">	ret = i2c_master_recv(client, tmp, count);</span><br><span class="line">	<span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">		ret = copy_to_user(buf, tmp, count) ? -EFAULT : ret;</span><br><span class="line">	kfree(tmp);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2cdev core主要通过设备节点的ioctrl操作导出i2c bus interface，通过ioctrl(I2C_RDWR,…)可以直接使用对应的i2c adapter传输特定i2c message，由于i2c message中包含target i2c device的地址信息，因而可以实现与特定i2c device的数据传输</p>
<p>然而当该controller不支持i2c protocol而只支持SMBus protocol，需要通过SMBus protocol进行数据传输，或需要通过read()/write()系统调用进行数据传输时，必须首先调用ioctrl(I2C_SLAVE/I2C_SLAVE_FORCE,…)在anonymous i2c client中设置相应的地址信息，之后通过read()/write()系统调用，或SMBus interface进行数据传输</p>
<p>当对设备节点进行读操作时，实际调用i2cdev_read()从特定i2c client接受i2c message，此时anonymous i2c client中已经保存target i2c client的地址信息；buf参数用于保存接收的数据，count参数表示需要接收的数据的长度，以字节为单位</p>
<ul>
<li>调用i2c_master_recv()接收i2c message，一共接收count字节的数据</li>
<li>将接收的数据拷贝到传入的用户态的buf缓存中</li>
</ul>
<h5 id="i2cdev-write"><a href="#i2cdev-write" class="headerlink" title="i2cdev_write"></a>i2cdev_write</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">i2cdev_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf,</span><br><span class="line">		size_t count, loff_t *offset)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">char</span> *tmp;</span><br><span class="line">	<span class="keyword">struct</span> i2c_client *client = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count &gt; <span class="number">8192</span>)</span><br><span class="line">		count = <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line">	tmp = memdup_user(buf, count);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(tmp))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(tmp);</span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">"i2c-dev: i2c-%d writing %zu bytes.\n"</span>,</span><br><span class="line">		iminor(file_inode(file)), count);</span><br><span class="line"></span><br><span class="line">	ret = i2c_master_send(client, tmp, count);</span><br><span class="line">	kfree(tmp);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当对设备节点进行写操作时，实际调用i2cdev_write()向特定i2c client发送i2c message，此时anonymous i2c client中已经保存target i2c client的地址信息；buf参数指向的缓存中保存有需要发送的的数据，count参数表示需要发送的数据的长度，以字节为单位</p>
<ul>
<li>将传入的buf缓存中保存的需要发送的数据拷贝到内核态缓存中</li>
<li>调用i2c_master_send()发送i2c message，一共发送count字节的数据</li>
</ul>
<h5 id="i2cdev-ioctl"><a href="#i2cdev-ioctl" class="headerlink" title="i2cdev_ioctl"></a>i2cdev_ioctl</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">static long i2cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_client *client = file-&gt;private_data;</span><br><span class="line">	unsigned long funcs;</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;client-&gt;adapter-&gt;dev, "ioctl, cmd=0x%02x, arg=0x%02lx\n",</span><br><span class="line">		cmd, arg);</span><br><span class="line"></span><br><span class="line">	switch (cmd) &#123;</span><br><span class="line">	case I2C_SLAVE:</span><br><span class="line">	case I2C_SLAVE_FORCE:</span><br><span class="line">		/* NOTE:  devices set up to work with "new style" drivers</span><br><span class="line">		 * can't use I2C_SLAVE, even when the device node is not</span><br><span class="line">		 * bound to a driver.  Only I2C_SLAVE_FORCE will work.</span><br><span class="line">		 *</span><br><span class="line">		 * Setting the PEC flag here won't affect kernel drivers,</span><br><span class="line">		 * which will be using the i2c_client node registered with</span><br><span class="line">		 * the driver model core.  Likewise, when that client has</span><br><span class="line">		 * the PEC flag already set, the i2c-dev driver won't see</span><br><span class="line">		 * (or use) this setting.</span><br><span class="line">		 */</span><br><span class="line">		if ((arg &gt; 0x3ff) ||</span><br><span class="line">		    (((client-&gt;flags &amp; I2C_M_TEN) == 0) &amp;&amp; arg &gt; 0x7f))</span><br><span class="line">			return -EINVAL;</span><br><span class="line">		if (cmd == I2C_SLAVE &amp;&amp; i2cdev_check_addr(client-&gt;adapter, arg))</span><br><span class="line">			return -EBUSY;</span><br><span class="line">		/* REVISIT: address could become busy later */</span><br><span class="line">		client-&gt;addr = arg;</span><br><span class="line">		return 0;</span><br><span class="line">	case I2C_TENBIT:</span><br><span class="line">		if (arg)</span><br><span class="line">			client-&gt;flags |= I2C_M_TEN;</span><br><span class="line">		else</span><br><span class="line">			client-&gt;flags &amp;= ~I2C_M_TEN;</span><br><span class="line">		return 0;</span><br><span class="line">	case I2C_PEC:</span><br><span class="line">		if (arg)</span><br><span class="line">			client-&gt;flags |= I2C_CLIENT_PEC;</span><br><span class="line">		else</span><br><span class="line">			client-&gt;flags &amp;= ~I2C_CLIENT_PEC;</span><br><span class="line">		return 0;</span><br><span class="line">	case I2C_FUNCS:</span><br><span class="line">		funcs = i2c_get_functionality(client-&gt;adapter);</span><br><span class="line">		return put_user(funcs, (unsigned long __user *)arg);</span><br><span class="line"></span><br><span class="line">	case I2C_RDWR:</span><br><span class="line">		return i2cdev_ioctl_rdrw(client, arg);</span><br><span class="line"></span><br><span class="line">	case I2C_SMBUS:</span><br><span class="line">		return i2cdev_ioctl_smbus(client, arg);</span><br><span class="line"></span><br><span class="line">	case I2C_RETRIES:</span><br><span class="line">		client-&gt;adapter-&gt;retries = arg;</span><br><span class="line">		break;</span><br><span class="line">	case I2C_TIMEOUT:</span><br><span class="line">		/* For historical reasons, user-space sets the timeout</span><br><span class="line">		 * value in units of 10 ms.</span><br><span class="line">		 */</span><br><span class="line">		client-&gt;adapter-&gt;timeout = msecs_to_jiffies(arg * 10);</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		/* NOTE:  returning a fault code here could cause trouble</span><br><span class="line">		 * in buggy userspace code.  Some old kernel bugs returned</span><br><span class="line">		 * zero in this case, and userspace code might accidentally</span><br><span class="line">		 * have depended on that bug.</span><br><span class="line">		 */</span><br><span class="line">		return -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2cdev_ioctl()导出i2c bus interface，包括</p>
<p>ioctl(file, I2C_SLAVE, long addr)<br>ioctl(file, I2C_SI2C_SLAVE_FORCELAVE, long addr)</p>
<p>I2C_SLAVE/I2C_SLAVE_FORCE用于设定anonymous i2c client的地址，传入的addr参数为需要设置的i2c地址，当对应地址处的i2c device已经与相应的i2c driver实现绑定时，必须使用I2C_SLAVE_FORCE设置anonymous i2c client的地址</p>
<p>ioctl(file, I2C_TENBIT, long select)</p>
<p>I2C_TENBIT用于设置或清除anonymous i2c client的I2C_M_TEN标志，若传入的参数select为1则设置I2C_M_TEN标志，否则清除I2C_M_TEN标志</p>
<p>ioctl(file, I2C_PEC, long select)</p>
<p>I2C_PEC用于设置或清除anonymous i2c client的I2C_CLIENT_PEC标志，若传入的参数select为1则设置I2C_CLIENT_PEC标志，否则清除I2C_CLIENT_PEC标志</p>
<p>ioctl(file, I2C_FUNCS, unsigned long *funcs)</p>
<p>I2C_FUNCS用于返回当前设备节点对应的i2c adapter支持的所有functionality，并保存在传入的funcs参数指向的缓存中</p>
<p>ioctl(file, I2C_RDWR, struct i2c_rdwr_ioctl_data *msgset)</p>
<p>I2C_RDWR用于实现I2C protocol数据传输，传输一个或多个i2c message</p>
<p>ioctl(file, I2C_SMBUS, struct i2c_smbus_ioctl_data *args)</p>
<p>I2C_SMBUS用于实现SMBus protocol数据传输，在进行SMBus protocol数据传输之前，必须首先调用I2C_SLAVE/I2C_SLAVE_FORCE ioctl设定anonymous i2c client的地址</p>
<p>ioctl(file, I2C_RETRIES, long retries)</p>
<p>I2C_RETRIES用于设置对应的i2c adapter的retries参数，传入的retries参数即为需要设置的重试次数</p>
<p>ioctl(file, I2C_TIMEOUT, long timeout_in_10ms)</p>
<p>I2C_RETRIES用于设置对应的i2c adapter的timeout参数，传入的timeout_in_10ms即为需要设置的超时时间，单位为10ms</p>
<h5 id="i2cdev-ioctl-rdrw"><a href="#i2cdev-ioctl-rdrw" class="headerlink" title="i2cdev_ioctl_rdrw"></a>i2cdev_ioctl_rdrw</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">static noinline int i2cdev_ioctl_rdrw(struct i2c_client *client,</span><br><span class="line">		unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">	struct i2c_rdwr_ioctl_data rdwr_arg;</span><br><span class="line">	struct i2c_msg *rdwr_pa;</span><br><span class="line">	u8 __user **data_ptrs;</span><br><span class="line">	int i, res;</span><br><span class="line"></span><br><span class="line">	if (copy_from_user(&amp;rdwr_arg,</span><br><span class="line">			   (struct i2c_rdwr_ioctl_data __user *)arg,</span><br><span class="line">			   sizeof(rdwr_arg)))</span><br><span class="line">		return -EFAULT;</span><br><span class="line"></span><br><span class="line">	/* Put an arbitrary limit on the number of messages that can</span><br><span class="line">	 * be sent at once */</span><br><span class="line">	if (rdwr_arg.nmsgs &gt; I2C_RDRW_IOCTL_MAX_MSGS)</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	rdwr_pa = memdup_user(rdwr_arg.msgs,</span><br><span class="line">			      rdwr_arg.nmsgs * sizeof(struct i2c_msg));</span><br><span class="line">	if (IS_ERR(rdwr_pa))</span><br><span class="line">		return PTR_ERR(rdwr_pa);</span><br><span class="line"></span><br><span class="line">	data_ptrs = kmalloc(rdwr_arg.nmsgs * sizeof(u8 __user *), GFP_KERNEL);</span><br><span class="line">	if (data_ptrs == NULL) &#123;</span><br><span class="line">		kfree(rdwr_pa);</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = 0;</span><br><span class="line">	for (i = 0; i &lt; rdwr_arg.nmsgs; i++) &#123;</span><br><span class="line">		/* Limit the size of the message to a sane amount */</span><br><span class="line">		if (rdwr_pa[i].len &gt; 8192) &#123;</span><br><span class="line">			res = -EINVAL;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		data_ptrs[i] = (u8 __user *)rdwr_pa[i].buf;</span><br><span class="line">		rdwr_pa[i].buf = memdup_user(data_ptrs[i], rdwr_pa[i].len);</span><br><span class="line">		if (IS_ERR(rdwr_pa[i].buf)) &#123;</span><br><span class="line">			res = PTR_ERR(rdwr_pa[i].buf);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/*</span><br><span class="line">		 * If the message length is received from the slave (similar</span><br><span class="line">		 * to SMBus block read), we must ensure that the buffer will</span><br><span class="line">		 * be large enough to cope with a message length of</span><br><span class="line">		 * I2C_SMBUS_BLOCK_MAX as this is the maximum underlying bus</span><br><span class="line">		 * drivers allow. The first byte in the buffer must be</span><br><span class="line">		 * pre-filled with the number of extra bytes, which must be</span><br><span class="line">		 * at least one to hold the message length, but can be</span><br><span class="line">		 * greater (for example to account for a checksum byte at</span><br><span class="line">		 * the end of the message.)</span><br><span class="line">		 */</span><br><span class="line">		if (rdwr_pa[i].flags &amp; I2C_M_RECV_LEN) &#123;</span><br><span class="line">			if (!(rdwr_pa[i].flags &amp; I2C_M_RD) ||</span><br><span class="line">			    rdwr_pa[i].buf[0] &lt; 1 ||</span><br><span class="line">			    rdwr_pa[i].len &lt; rdwr_pa[i].buf[0] +</span><br><span class="line">					     I2C_SMBUS_BLOCK_MAX) &#123;</span><br><span class="line">				res = -EINVAL;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			rdwr_pa[i].len = rdwr_pa[i].buf[0];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (res &lt; 0) &#123;</span><br><span class="line">		int j;</span><br><span class="line">		for (j = 0; j &lt; i; ++j)</span><br><span class="line">			kfree(rdwr_pa[j].buf);</span><br><span class="line">		kfree(data_ptrs);</span><br><span class="line">		kfree(rdwr_pa);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = i2c_transfer(client-&gt;adapter, rdwr_pa, rdwr_arg.nmsgs);</span><br><span class="line">	while (i-- &gt; 0) &#123;</span><br><span class="line">		if (res &gt;= 0 &amp;&amp; (rdwr_pa[i].flags &amp; I2C_M_RD)) &#123;</span><br><span class="line">			if (copy_to_user(data_ptrs[i], rdwr_pa[i].buf,</span><br><span class="line">					 rdwr_pa[i].len))</span><br><span class="line">				res = -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		kfree(rdwr_pa[i].buf);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(data_ptrs);</span><br><span class="line">	kfree(rdwr_pa);</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2cdev_ioctl_rdrw()用于实现i2cdev中的I2C protocol数据传输，传入的arg参数实际为i2c_rdwr_ioctl_data结构，其中保存需要传输的一个或多个i2c message</p>
<ul>
<li>实际调用i2c_transfer()对i2c_rdwr_ioctl_data中包含的一个或多个i2c message进行传输</li>
</ul>
<h5 id="i2cdev-ioctl-smbus"><a href="#i2cdev-ioctl-smbus" class="headerlink" title="i2cdev_ioctl_smbus"></a>i2cdev_ioctl_smbus</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">int</span> <span class="title">i2cdev_ioctl_smbus</span><span class="params">(<span class="keyword">struct</span> i2c_client *client,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_smbus_ioctl_data data_arg;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data temp;</span><br><span class="line">	<span class="keyword">int</span> datasize, res;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;data_arg,</span><br><span class="line">			   (<span class="keyword">struct</span> i2c_smbus_ioctl_data __user *) arg,</span><br><span class="line">			   <span class="keyword">sizeof</span>(<span class="keyword">struct</span> i2c_smbus_ioctl_data)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> ((data_arg.size != I2C_SMBUS_BYTE) &amp;&amp;</span><br><span class="line">	    (data_arg.size != I2C_SMBUS_QUICK) &amp;&amp;</span><br><span class="line">	    (data_arg.size != I2C_SMBUS_BYTE_DATA) &amp;&amp;</span><br><span class="line">	    (data_arg.size != I2C_SMBUS_WORD_DATA) &amp;&amp;</span><br><span class="line">	    (data_arg.size != I2C_SMBUS_PROC_CALL) &amp;&amp;</span><br><span class="line">	    (data_arg.size != I2C_SMBUS_BLOCK_DATA) &amp;&amp;</span><br><span class="line">	    (data_arg.size != I2C_SMBUS_I2C_BLOCK_BROKEN) &amp;&amp;</span><br><span class="line">	    (data_arg.size != I2C_SMBUS_I2C_BLOCK_DATA) &amp;&amp;</span><br><span class="line">	    (data_arg.size != I2C_SMBUS_BLOCK_PROC_CALL)) &#123;</span><br><span class="line">		dev_dbg(&amp;client-&gt;adapter-&gt;dev,</span><br><span class="line">			<span class="string">"size out of range (%x) in ioctl I2C_SMBUS.\n"</span>,</span><br><span class="line">			data_arg.size);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Note that I2C_SMBUS_READ and I2C_SMBUS_WRITE are 0 and 1,</span><br><span class="line">	   so the check is valid if size==I2C_SMBUS_QUICK too. */</span></span><br><span class="line">	<span class="keyword">if</span> ((data_arg.read_write != I2C_SMBUS_READ) &amp;&amp;</span><br><span class="line">	    (data_arg.read_write != I2C_SMBUS_WRITE)) &#123;</span><br><span class="line">		dev_dbg(&amp;client-&gt;adapter-&gt;dev,</span><br><span class="line">			<span class="string">"read_write out of range (%x) in ioctl I2C_SMBUS.\n"</span>,</span><br><span class="line">			data_arg.read_write);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Note that command values are always valid! */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((data_arg.size == I2C_SMBUS_QUICK) ||</span><br><span class="line">	    ((data_arg.size == I2C_SMBUS_BYTE) &amp;&amp;</span><br><span class="line">	    (data_arg.read_write == I2C_SMBUS_WRITE)))</span><br><span class="line">		<span class="comment">/* These are special: we do not use data */</span></span><br><span class="line">		<span class="keyword">return</span> i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr,</span><br><span class="line">				      client-&gt;flags, data_arg.read_write,</span><br><span class="line">				      data_arg.command, data_arg.size, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (data_arg.data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		dev_dbg(&amp;client-&gt;adapter-&gt;dev,</span><br><span class="line">			<span class="string">"data is NULL pointer in ioctl I2C_SMBUS.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((data_arg.size == I2C_SMBUS_BYTE_DATA) ||</span><br><span class="line">	    (data_arg.size == I2C_SMBUS_BYTE))</span><br><span class="line">		datasize = <span class="keyword">sizeof</span>(data_arg.data-&gt;byte);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((data_arg.size == I2C_SMBUS_WORD_DATA) ||</span><br><span class="line">		 (data_arg.size == I2C_SMBUS_PROC_CALL))</span><br><span class="line">		datasize = <span class="keyword">sizeof</span>(data_arg.data-&gt;word);</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* size == smbus block, i2c block, or block proc. call */</span></span><br><span class="line">		datasize = <span class="keyword">sizeof</span>(data_arg.data-&gt;block);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((data_arg.size == I2C_SMBUS_PROC_CALL) ||</span><br><span class="line">	    (data_arg.size == I2C_SMBUS_BLOCK_PROC_CALL) ||</span><br><span class="line">	    (data_arg.size == I2C_SMBUS_I2C_BLOCK_DATA) ||</span><br><span class="line">	    (data_arg.read_write == I2C_SMBUS_WRITE)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;temp, data_arg.data, datasize))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (data_arg.size == I2C_SMBUS_I2C_BLOCK_BROKEN) &#123;</span><br><span class="line">		<span class="comment">/* Convert old I2C block commands to the new</span><br><span class="line">		   convention. This preserves binary compatibility. */</span></span><br><span class="line">		data_arg.size = I2C_SMBUS_I2C_BLOCK_DATA;</span><br><span class="line">		<span class="keyword">if</span> (data_arg.read_write == I2C_SMBUS_READ)</span><br><span class="line">			temp.block[<span class="number">0</span>] = I2C_SMBUS_BLOCK_MAX;</span><br><span class="line">	&#125;</span><br><span class="line">	res = i2c_smbus_xfer(client-&gt;adapter, client-&gt;addr, client-&gt;flags,</span><br><span class="line">	      data_arg.read_write, data_arg.command, data_arg.size, &amp;temp);</span><br><span class="line">	<span class="keyword">if</span> (!res &amp;&amp; ((data_arg.size == I2C_SMBUS_PROC_CALL) ||</span><br><span class="line">		     (data_arg.size == I2C_SMBUS_BLOCK_PROC_CALL) ||</span><br><span class="line">		     (data_arg.read_write == I2C_SMBUS_READ))) &#123;</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(data_arg.data, &amp;temp, datasize))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2cdev_ioctl_smbus()用于实现i2cdev中的SMBus protocol数据传输，传入的arg参数实际为i2c_smbus_ioctl_data结构</p>
<ul>
<li>实际调用i2c_smbus_xfer()对i2c_smbus_ioctl_data中包含的数据进行传输</li>
</ul>
<h5 id="i2cdev-SMBus-userspace-interface"><a href="#i2cdev-SMBus-userspace-interface" class="headerlink" title="i2cdev SMBus userspace interface"></a>i2cdev SMBus userspace interface</h5><p>通常不直接调用ioctrl(I2C_SMBUS,…)进行SMBus protocol数据传输，而是调用用户态的<code>include/linux/i2c-dev.h</code>中定义的一系列接口进行SMBus protocol数据传输</p>
<h6 id="i2c-smbus-access"><a href="#i2c-smbus-access" class="headerlink" title="i2c_smbus_access"></a>i2c_smbus_access</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __<span class="function">s32 <span class="title">i2c_smbus_access</span><span class="params">(<span class="keyword">int</span> file, <span class="keyword">char</span> read_write, __u8 command, </span><br><span class="line">                                     <span class="keyword">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> i2c_smbus_ioctl_data args;</span><br><span class="line"></span><br><span class="line">	args.read_write = read_write;</span><br><span class="line">	args.command = command;</span><br><span class="line">	args.size = size;</span><br><span class="line">	args.data = data;</span><br><span class="line">	<span class="keyword">return</span> ioctl(file,I2C_SMBUS,&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i2c_smbus_access()通过ioctrl(I2C_SMBUS,…)对特定i2c client进行SMBus protocol数据传输，在此之前必须调用ioctrl(I2C_SLAVE,…)设定target i2c client的地址</p>
<p>成功返回0，否则返回-1</p>
<p>@file           打开的i2c adapter的设备节点的文件描述符<br>@read_write     对应于i2c_smbus_ioctl_data.read_write<br>@comand         对应于i2c_smbus_ioctl_data.command<br>@size           对应于i2c_smbus_ioctl_data.size<br>@data           对应于i2c_smbus_ioctl_data.data</p>
<h6 id="i2c-smbus-write-quick"><a href="#i2c-smbus-write-quick" class="headerlink" title="i2c_smbus_write_quick"></a>i2c_smbus_write_quick</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __<span class="function">s32 <span class="title">i2c_smbus_write_quick</span><span class="params">(<span class="keyword">int</span> file, __u8 value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_access(file,value,<span class="number">0</span>,I2C_SMBUS_QUICK,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="i2c-smbus-read-byte-1"><a href="#i2c-smbus-read-byte-1" class="headerlink" title="i2c_smbus_read_byte"></a>i2c_smbus_read_byte</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __<span class="function">s32 <span class="title">i2c_smbus_read_byte</span><span class="params">(<span class="keyword">int</span> file)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	<span class="keyword">if</span> (i2c_smbus_access(file,I2C_SMBUS_READ,<span class="number">0</span>,I2C_SMBUS_BYTE,&amp;data))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0x0FF</span> &amp; data.byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="i2c-smbus-write-byte-1"><a href="#i2c-smbus-write-byte-1" class="headerlink" title="i2c_smbus_write_byte"></a>i2c_smbus_write_byte</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __<span class="function">s32 <span class="title">i2c_smbus_write_byte</span><span class="params">(<span class="keyword">int</span> file, __u8 value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_access(file,I2C_SMBUS_WRITE,value,</span><br><span class="line">	                        I2C_SMBUS_BYTE,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="i2c-smbus-read-byte-data-1"><a href="#i2c-smbus-read-byte-data-1" class="headerlink" title="i2c_smbus_read_byte_data"></a>i2c_smbus_read_byte_data</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __<span class="function">s32 <span class="title">i2c_smbus_read_byte_data</span><span class="params">(<span class="keyword">int</span> file, __u8 command)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	<span class="keyword">if</span> (i2c_smbus_access(file,I2C_SMBUS_READ,command,</span><br><span class="line">	                     I2C_SMBUS_BYTE_DATA,&amp;data))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0x0FF</span> &amp; data.byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="i2c-smbus-write-byte-data-1"><a href="#i2c-smbus-write-byte-data-1" class="headerlink" title="i2c_smbus_write_byte_data"></a>i2c_smbus_write_byte_data</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __<span class="function">s32 <span class="title">i2c_smbus_write_byte_data</span><span class="params">(<span class="keyword">int</span> file, __u8 command, </span><br><span class="line">                                              __u8 value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	data.byte = value;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_access(file,I2C_SMBUS_WRITE,command,</span><br><span class="line">	                        I2C_SMBUS_BYTE_DATA, &amp;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="i2c-smbus-read-word-data-1"><a href="#i2c-smbus-read-word-data-1" class="headerlink" title="i2c_smbus_read_word_data"></a>i2c_smbus_read_word_data</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __<span class="function">s32 <span class="title">i2c_smbus_read_word_data</span><span class="params">(<span class="keyword">int</span> file, __u8 command)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	<span class="keyword">if</span> (i2c_smbus_access(file,I2C_SMBUS_READ,command,</span><br><span class="line">	                     I2C_SMBUS_WORD_DATA,&amp;data))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0x0FFFF</span> &amp; data.word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="i2c-smbus-write-word-data-1"><a href="#i2c-smbus-write-word-data-1" class="headerlink" title="i2c_smbus_write_word_data"></a>i2c_smbus_write_word_data</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __<span class="function">s32 <span class="title">i2c_smbus_write_word_data</span><span class="params">(<span class="keyword">int</span> file, __u8 command, </span><br><span class="line">                                              __u16 value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	data.word = value;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_access(file,I2C_SMBUS_WRITE,command,</span><br><span class="line">	                        I2C_SMBUS_WORD_DATA, &amp;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="i2c-smbus-process-call"><a href="#i2c-smbus-process-call" class="headerlink" title="i2c_smbus_process_call"></a>i2c_smbus_process_call</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __<span class="function">s32 <span class="title">i2c_smbus_process_call</span><span class="params">(<span class="keyword">int</span> file, __u8 command, __u16 value)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	data.word = value;</span><br><span class="line">	<span class="keyword">if</span> (i2c_smbus_access(file,I2C_SMBUS_WRITE,command,</span><br><span class="line">	                     I2C_SMBUS_PROC_CALL,&amp;data))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0x0FFFF</span> &amp; data.word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="i2c-smbus-read-block-data-1"><a href="#i2c-smbus-read-block-data-1" class="headerlink" title="i2c_smbus_read_block_data"></a>i2c_smbus_read_block_data</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns the number of read bytes */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __<span class="function">s32 <span class="title">i2c_smbus_read_block_data</span><span class="params">(<span class="keyword">int</span> file, __u8 command, </span><br><span class="line">                                              __u8 *values)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (i2c_smbus_access(file,I2C_SMBUS_READ,command,</span><br><span class="line">	                     I2C_SMBUS_BLOCK_DATA,&amp;data))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= data.block[<span class="number">0</span>]; i++)</span><br><span class="line">			values[i<span class="number">-1</span>] = data.block[i];</span><br><span class="line">			<span class="keyword">return</span> data.block[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="i2c-smbus-write-block-data-1"><a href="#i2c-smbus-write-block-data-1" class="headerlink" title="i2c_smbus_write_block_data"></a>i2c_smbus_write_block_data</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __<span class="function">s32 <span class="title">i2c_smbus_write_block_data</span><span class="params">(<span class="keyword">int</span> file, __u8 command, </span><br><span class="line">                                               __u8 length, __u8 *values)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (length &gt; <span class="number">32</span>)</span><br><span class="line">		length = <span class="number">32</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= length; i++)</span><br><span class="line">		data.block[i] = values[i<span class="number">-1</span>];</span><br><span class="line">	data.block[<span class="number">0</span>] = length;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_access(file,I2C_SMBUS_WRITE,command,</span><br><span class="line">	                        I2C_SMBUS_BLOCK_DATA, &amp;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="i2c-smbus-write-i2c-block-data-1"><a href="#i2c-smbus-write-i2c-block-data-1" class="headerlink" title="i2c_smbus_write_i2c_block_data"></a>i2c_smbus_write_i2c_block_data</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> __<span class="function">s32 <span class="title">i2c_smbus_write_i2c_block_data</span><span class="params">(<span class="keyword">int</span> file, __u8 command,</span><br><span class="line">                                               __u8 length, __u8 *values)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span> i2c_smbus_data data;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (length &gt; <span class="number">32</span>)</span><br><span class="line">		length = <span class="number">32</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= length; i++)</span><br><span class="line">		data.block[i] = values[i<span class="number">-1</span>];</span><br><span class="line">	data.block[<span class="number">0</span>] = length;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_access(file,I2C_SMBUS_WRITE,command,</span><br><span class="line">	                        I2C_SMBUS_I2C_BLOCK_DATA, &amp;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/kernel/" rel="tag">#kernel</a>
          
            <a href="/tags/bus/" rel="tag">#bus</a>
          
        </div>
      

      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Jeffle" />
          <p class="site-author-name" itemprop="name">Jeffle</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">1</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-I2C-Framework"><span class="nav-number">1.</span> <span class="nav-text">Linux I2C Framework</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I2C-Bus-Protocol"><span class="nav-number">1.1.</span> <span class="nav-text">I2C Bus Protocol</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bus-Specification"><span class="nav-number">1.1.1.</span> <span class="nav-text">Bus Specification</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#信号"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时序"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">时序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#硬件拓扑"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">硬件拓扑</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#形态1"><span class="nav-number">1.1.1.3.1.</span> <span class="nav-text">形态1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#形态2"><span class="nav-number">1.1.1.3.2.</span> <span class="nav-text">形态2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-Transfer"><span class="nav-number">1.1.2.</span> <span class="nav-text">Data Transfer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Standard-I2C-Protocol"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">Standard I2C Protocol</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-master-send"><span class="nav-number">1.1.2.1.1.</span> <span class="nav-text">i2c_master_send</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-master-recv"><span class="nav-number">1.1.2.1.2.</span> <span class="nav-text">i2c_master_recv</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-transfer"><span class="nav-number">1.1.2.1.3.</span> <span class="nav-text">i2c_transfer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-M-NOSTART"><span class="nav-number">1.1.2.1.4.</span> <span class="nav-text">I2C_M_NOSTART</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-M-IGNORE-NAK"><span class="nav-number">1.1.2.1.5.</span> <span class="nav-text">I2C_M_IGNORE_NAK</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-M-REV-DIR-ADDR"><span class="nav-number">1.1.2.1.6.</span> <span class="nav-text">I2C_M_REV_DIR_ADDR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-M-STOP"><span class="nav-number">1.1.2.1.7.</span> <span class="nav-text">I2C_M_STOP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-M-NO-RD-ACK"><span class="nav-number">1.1.2.1.8.</span> <span class="nav-text">I2C_M_NO_RD_ACK</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SMBus-Protocol"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">SMBus Protocol</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Packet-Error-Checking-PEC"><span class="nav-number">1.1.2.2.1.</span> <span class="nav-text">Packet Error Checking (PEC)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-FUNC-SMBUS-QUICK"><span class="nav-number">1.1.2.2.2.</span> <span class="nav-text">I2C_FUNC_SMBUS_QUICK</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-FUNC-SMBUS-READ-BYTE"><span class="nav-number">1.1.2.2.3.</span> <span class="nav-text">I2C_FUNC_SMBUS_READ_BYTE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-FUNC-SMBUS-WRITE-BYTE"><span class="nav-number">1.1.2.2.4.</span> <span class="nav-text">I2C_FUNC_SMBUS_WRITE_BYTE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-FUNC-SMBUS-READ-BYTE-DATA"><span class="nav-number">1.1.2.2.5.</span> <span class="nav-text">I2C_FUNC_SMBUS_READ_BYTE_DATA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-FUNC-SMBUS-WRITE-BYTE-DATA"><span class="nav-number">1.1.2.2.6.</span> <span class="nav-text">I2C_FUNC_SMBUS_WRITE_BYTE_DATA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-FUNC-SMBUS-READ-WORD-DATA"><span class="nav-number">1.1.2.2.7.</span> <span class="nav-text">I2C_FUNC_SMBUS_READ_WORD_DATA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-FUNC-SMBUS-WRITE-WORD-DATA"><span class="nav-number">1.1.2.2.8.</span> <span class="nav-text">I2C_FUNC_SMBUS_WRITE_WORD_DATA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-FUNC-SMBUS-READ-BLOCK-DATA"><span class="nav-number">1.1.2.2.9.</span> <span class="nav-text">I2C_FUNC_SMBUS_READ_BLOCK_DATA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-FUNC-SMBUS-WRITE-BLOCK-DATA"><span class="nav-number">1.1.2.2.10.</span> <span class="nav-text">I2C_FUNC_SMBUS_WRITE_BLOCK_DATA</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-FUNC-SMBUS-PROC-CALL"><span class="nav-number">1.1.2.2.11.</span> <span class="nav-text">I2C_FUNC_SMBUS_PROC_CALL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-FUNC-SMBUS-BLOCK-PROC-CALL"><span class="nav-number">1.1.2.2.12.</span> <span class="nav-text">I2C_FUNC_SMBUS_BLOCK_PROC_CALL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SMBus-Host-Notify"><span class="nav-number">1.1.2.2.13.</span> <span class="nav-text">SMBus Host Notify</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-FUNC-SMBUS-READ-I2C-BLOCK"><span class="nav-number">1.1.2.2.14.</span> <span class="nav-text">I2C_FUNC_SMBUS_READ_I2C_BLOCK</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-FUNC-SMBUS-WRITE-I2C-BLOCK"><span class="nav-number">1.1.2.2.15.</span> <span class="nav-text">I2C_FUNC_SMBUS_WRITE_I2C_BLOCK</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I2C-Framework"><span class="nav-number">1.2.</span> <span class="nav-text">I2C Framework</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构"><span class="nav-number">1.2.1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c-adapter"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">i2c_adapter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c-algorithm"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">i2c_algorithm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c-client"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">i2c_client</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c-driver"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">i2c_driver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c-devinfo"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">i2c_devinfo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c-board-info"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">i2c_board_info</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c-device-id"><span class="nav-number">1.2.1.7.</span> <span class="nav-text">i2c_device_id</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c-msg"><span class="nav-number">1.2.1.8.</span> <span class="nav-text">i2c_msg</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c-smbus-data"><span class="nav-number">1.2.1.9.</span> <span class="nav-text">i2c_smbus_data</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I2C-framework-init"><span class="nav-number">1.2.2.</span> <span class="nav-text">I2C framework init</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-core-init"><span class="nav-number">1.2.2.0.1.</span> <span class="nav-text">I2C core init</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#board-specific-init"><span class="nav-number">1.2.2.0.2.</span> <span class="nav-text">board-specific init</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-adapter-driver-register"><span class="nav-number">1.2.2.0.3.</span> <span class="nav-text">i2c adapter driver register</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-devinit"><span class="nav-number">1.2.2.0.4.</span> <span class="nav-text">i2c devinit</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Summary"><span class="nav-number">1.2.3.</span> <span class="nav-text">Summary</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#device-adding"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">device adding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#device-matching"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">device matching</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#register-configuration"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">register configuration</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I2C-core"><span class="nav-number">1.2.4.</span> <span class="nav-text">I2C core</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c-bus-operations"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">i2c bus operations</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-bus-type"><span class="nav-number">1.2.4.1.1.</span> <span class="nav-text">i2c_bus_type</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-device-match"><span class="nav-number">1.2.4.1.2.</span> <span class="nav-text">i2c_device_match</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-device-probe"><span class="nav-number">1.2.4.1.3.</span> <span class="nav-text">i2c_device_probe</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-for-each-dev"><span class="nav-number">1.2.4.1.4.</span> <span class="nav-text">i2c_for_each_dev</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c-adapter-driver-API"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">i2c adapter driver API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-add-adapter"><span class="nav-number">1.2.4.2.1.</span> <span class="nav-text">i2c_add_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-add-numbered-adapter"><span class="nav-number">1.2.4.2.2.</span> <span class="nav-text">i2c_add_numbered_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-register-adapter"><span class="nav-number">1.2.4.2.3.</span> <span class="nav-text">i2c_register_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-del-adapter"><span class="nav-number">1.2.4.2.4.</span> <span class="nav-text">i2c_del_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-lock-adapter"><span class="nav-number">1.2.4.2.5.</span> <span class="nav-text">i2c_lock_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-trylock-adapter"><span class="nav-number">1.2.4.2.6.</span> <span class="nav-text">i2c_trylock_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-unlock-adapter"><span class="nav-number">1.2.4.2.7.</span> <span class="nav-text">i2c_unlock_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-set-adapter-bus-clk-rate"><span class="nav-number">1.2.4.2.8.</span> <span class="nav-text">i2c_set_adapter_bus_clk_rate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-get-adapter-bus-clk-rate"><span class="nav-number">1.2.4.2.9.</span> <span class="nav-text">i2c_get_adapter_bus_clk_rate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-shutdown-adapter"><span class="nav-number">1.2.4.2.10.</span> <span class="nav-text">i2c_shutdown_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-shutdown-clear-adapter"><span class="nav-number">1.2.4.2.11.</span> <span class="nav-text">i2c_shutdown_clear_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-get-adapdata"><span class="nav-number">1.2.4.2.12.</span> <span class="nav-text">i2c_get_adapdata</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-set-adapdata"><span class="nav-number">1.2.4.2.13.</span> <span class="nav-text">i2c_set_adapdata</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-parent-is-i2c-adapter"><span class="nav-number">1.2.4.2.14.</span> <span class="nav-text">i2c_parent_is_i2c_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-get-adapter"><span class="nav-number">1.2.4.2.15.</span> <span class="nav-text">i2c_get_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-put-adapter"><span class="nav-number">1.2.4.2.16.</span> <span class="nav-text">i2c_put_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-clients-command"><span class="nav-number">1.2.4.2.17.</span> <span class="nav-text">i2c_clients_command</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c-client-driver-API"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">i2c client driver API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-new-device"><span class="nav-number">1.2.4.3.1.</span> <span class="nav-text">i2c_new_device</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-new-probed-device"><span class="nav-number">1.2.4.3.2.</span> <span class="nav-text">i2c_new_probed_device</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-new-dummy"><span class="nav-number">1.2.4.3.3.</span> <span class="nav-text">i2c_new_dummy</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-unregister-device"><span class="nav-number">1.2.4.3.4.</span> <span class="nav-text">i2c_unregister_device</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-verify-client"><span class="nav-number">1.2.4.3.5.</span> <span class="nav-text">i2c_verify_client</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-verify-adapter"><span class="nav-number">1.2.4.3.6.</span> <span class="nav-text">i2c_verify_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-get-clientdata"><span class="nav-number">1.2.4.3.7.</span> <span class="nav-text">i2c_get_clientdata</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-set-clientdata"><span class="nav-number">1.2.4.3.8.</span> <span class="nav-text">i2c_set_clientdata</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-use-client"><span class="nav-number">1.2.4.3.9.</span> <span class="nav-text">i2c_use_client</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-release-client"><span class="nav-number">1.2.4.3.10.</span> <span class="nav-text">i2c_release_client</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-register-driver"><span class="nav-number">1.2.4.3.11.</span> <span class="nav-text">i2c_register_driver</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-add-driver"><span class="nav-number">1.2.4.3.12.</span> <span class="nav-text">i2c_add_driver</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-del-driver"><span class="nav-number">1.2.4.3.13.</span> <span class="nav-text">i2c_del_driver</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2c-board-info-operations"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">i2c board info operations</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-board-list-链表"><span class="nav-number">1.2.4.4.1.</span> <span class="nav-text">__i2c_board_list 链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#I2C-BOARD-INFO"><span class="nav-number">1.2.4.4.2.</span> <span class="nav-text">I2C_BOARD_INFO</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-register-board-info"><span class="nav-number">1.2.4.4.3.</span> <span class="nav-text">i2c_register_board_info</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#standard-I2C-protocol-data-transfer"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">standard I2C protocol data transfer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-master-send-1"><span class="nav-number">1.2.4.5.1.</span> <span class="nav-text">i2c_master_send</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-master-recv-1"><span class="nav-number">1.2.4.5.2.</span> <span class="nav-text">i2c_master_recv</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-transfer-1"><span class="nav-number">1.2.4.5.3.</span> <span class="nav-text">i2c_transfer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-transfer-2"><span class="nav-number">1.2.4.5.4.</span> <span class="nav-text">__i2c_transfer</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SMBus-protocol-data-transfer"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">SMBus protocol data transfer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-xfer"><span class="nav-number">1.2.4.6.1.</span> <span class="nav-text">i2c_smbus_xfer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-probe-func-quick-read"><span class="nav-number">1.2.4.6.2.</span> <span class="nav-text">i2c_probe_func_quick_read</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-read-byte"><span class="nav-number">1.2.4.6.3.</span> <span class="nav-text">i2c_smbus_read_byte</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-write-byte"><span class="nav-number">1.2.4.6.4.</span> <span class="nav-text">i2c_smbus_write_byte</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-read-byte-data"><span class="nav-number">1.2.4.6.5.</span> <span class="nav-text">i2c_smbus_read_byte_data</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-write-byte-data"><span class="nav-number">1.2.4.6.6.</span> <span class="nav-text">i2c_smbus_write_byte_data</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-read-word-data"><span class="nav-number">1.2.4.6.7.</span> <span class="nav-text">i2c_smbus_read_word_data</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-write-word-data"><span class="nav-number">1.2.4.6.8.</span> <span class="nav-text">i2c_smbus_write_word_data</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-read-word-swapped"><span class="nav-number">1.2.4.6.9.</span> <span class="nav-text">i2c_smbus_read_word_swapped</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-write-word-swapped"><span class="nav-number">1.2.4.6.10.</span> <span class="nav-text">i2c_smbus_write_word_swapped</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-read-block-data"><span class="nav-number">1.2.4.6.11.</span> <span class="nav-text">i2c_smbus_read_block_data</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-write-block-data"><span class="nav-number">1.2.4.6.12.</span> <span class="nav-text">i2c_smbus_write_block_data</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-read-i2c-block-data"><span class="nav-number">1.2.4.6.13.</span> <span class="nav-text">i2c_smbus_read_i2c_block_data</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-write-i2c-block-data"><span class="nav-number">1.2.4.6.14.</span> <span class="nav-text">i2c_smbus_write_i2c_block_data</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-xfer-emulated"><span class="nav-number">1.2.4.6.15.</span> <span class="nav-text">i2c_smbus_xfer_emulated</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I2C-Sysfs"><span class="nav-number">1.2.4.7.</span> <span class="nav-text">I2C Sysfs</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-adapter-sysfs"><span class="nav-number">1.2.4.7.1.</span> <span class="nav-text">i2c adapter sysfs</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#name"><span class="nav-number">1.2.4.7.1.1.</span> <span class="nav-text">name</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#new-device"><span class="nav-number">1.2.4.7.1.2.</span> <span class="nav-text">new_device</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#delete-device"><span class="nav-number">1.2.4.7.1.3.</span> <span class="nav-text">delete_device</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#bus-clk-rate"><span class="nav-number">1.2.4.7.1.4.</span> <span class="nav-text">bus_clk_rate</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-client-sysfs"><span class="nav-number">1.2.4.7.2.</span> <span class="nav-text">i2c client sysfs</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#name-1"><span class="nav-number">1.2.4.7.2.1.</span> <span class="nav-text">name</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#modalias"><span class="nav-number">1.2.4.7.2.2.</span> <span class="nav-text">modalias</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I2C-OF-Support"><span class="nav-number">1.2.5.</span> <span class="nav-text">I2C OF Support</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#I2C-OF-Interface"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">I2C OF Interface</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#of-find-i2c-device-by-node"><span class="nav-number">1.2.5.1.1.</span> <span class="nav-text">of_find_i2c_device_by_node</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#of-find-i2c-adapter-by-node"><span class="nav-number">1.2.5.1.2.</span> <span class="nav-text">of_find_i2c_adapter_by_node</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#of-i2c-register-devices"><span class="nav-number">1.2.5.1.3.</span> <span class="nav-text">of_i2c_register_devices</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I2C-Algorithm"><span class="nav-number">1.2.6.</span> <span class="nav-text">I2C Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构-1"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-algo-bit-data"><span class="nav-number">1.2.6.1.1.</span> <span class="nav-text">i2c_algo_bit_data</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Signal-Manipulation"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">Signal Manipulation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SDA-SCL-Manipulation"><span class="nav-number">1.2.6.2.1.</span> <span class="nav-text">SDA/SCL Manipulation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-start"><span class="nav-number">1.2.6.2.2.</span> <span class="nav-text">i2c_start</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-repstart"><span class="nav-number">1.2.6.2.3.</span> <span class="nav-text">i2c_repstart</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-stop"><span class="nav-number">1.2.6.2.4.</span> <span class="nav-text">i2c_stop</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Protocol-Manipulation"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">Protocol Manipulation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-inb"><span class="nav-number">1.2.6.3.1.</span> <span class="nav-text">i2c_inb</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-outb"><span class="nav-number">1.2.6.3.2.</span> <span class="nav-text">i2c_outb</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bit-doAddress"><span class="nav-number">1.2.6.3.3.</span> <span class="nav-text">bit_doAddress</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#readbytes"><span class="nav-number">1.2.6.3.4.</span> <span class="nav-text">readbytes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sendbytes"><span class="nav-number">1.2.6.3.5.</span> <span class="nav-text">sendbytes</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Algorithm-Core"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">Algorithm Core</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-bit-algo"><span class="nav-number">1.2.6.4.1.</span> <span class="nav-text">i2c_bit_algo</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bit-func"><span class="nav-number">1.2.6.4.2.</span> <span class="nav-text">bit_func</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bit-xfer"><span class="nav-number">1.2.6.4.3.</span> <span class="nav-text">bit_xfer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-bit-add-bus"><span class="nav-number">1.2.6.4.4.</span> <span class="nav-text">i2c_bit_add_bus</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-bit-add-numbered-bus"><span class="nav-number">1.2.6.4.5.</span> <span class="nav-text">i2c_bit_add_numbered_bus</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I2C-Mux"><span class="nav-number">1.2.7.</span> <span class="nav-text">I2C Mux</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构-2"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-mux-priv"><span class="nav-number">1.2.7.1.1.</span> <span class="nav-text">i2c_mux_priv</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I2C-mux-core"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">I2C mux core</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-add-mux-adapter"><span class="nav-number">1.2.7.2.1.</span> <span class="nav-text">i2c_add_mux_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-del-mux-adapter"><span class="nav-number">1.2.7.2.2.</span> <span class="nav-text">i2c_del_mux_adapter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-mux-functionality"><span class="nav-number">1.2.7.2.3.</span> <span class="nav-text">i2c_mux_functionality</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-mux-master-xfer"><span class="nav-number">1.2.7.2.4.</span> <span class="nav-text">i2c_mux_master_xfer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-mux-smbus-xfer"><span class="nav-number">1.2.7.2.5.</span> <span class="nav-text">i2c_mux_smbus_xfer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#i2cdev"><span class="nav-number">1.2.8.</span> <span class="nav-text">i2cdev</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构-3"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-dev"><span class="nav-number">1.2.8.1.1.</span> <span class="nav-text">i2c_dev</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-rdwr-ioctl-data"><span class="nav-number">1.2.8.1.2.</span> <span class="nav-text">i2c_rdwr_ioctl_data</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-smbus-ioctl-data"><span class="nav-number">1.2.8.1.3.</span> <span class="nav-text">i2c_smbus_ioctl_data</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#device-number"><span class="nav-number">1.2.8.1.4.</span> <span class="nav-text">device number</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-dev-list-链表"><span class="nav-number">1.2.8.1.5.</span> <span class="nav-text">i2c_dev_list 链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-dev-class"><span class="nav-number">1.2.8.1.6.</span> <span class="nav-text">i2c_dev_class</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2cdev-core-init"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">i2cdev core init</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2c-dev-init"><span class="nav-number">1.2.8.2.1.</span> <span class="nav-text">i2c_dev_init</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2cdev-notifier"><span class="nav-number">1.2.8.2.2.</span> <span class="nav-text">i2cdev_notifier</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#i2cdev-core"><span class="nav-number">1.2.8.3.</span> <span class="nav-text">i2cdev core</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#i2cdev-fops"><span class="nav-number">1.2.8.3.1.</span> <span class="nav-text">i2cdev_fops</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2cdev-open"><span class="nav-number">1.2.8.3.2.</span> <span class="nav-text">i2cdev_open</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2cdev-read"><span class="nav-number">1.2.8.3.3.</span> <span class="nav-text">i2cdev_read</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2cdev-write"><span class="nav-number">1.2.8.3.4.</span> <span class="nav-text">i2cdev_write</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2cdev-ioctl"><span class="nav-number">1.2.8.3.5.</span> <span class="nav-text">i2cdev_ioctl</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2cdev-ioctl-rdrw"><span class="nav-number">1.2.8.3.6.</span> <span class="nav-text">i2cdev_ioctl_rdrw</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2cdev-ioctl-smbus"><span class="nav-number">1.2.8.3.7.</span> <span class="nav-text">i2cdev_ioctl_smbus</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#i2cdev-SMBus-userspace-interface"><span class="nav-number">1.2.8.3.8.</span> <span class="nav-text">i2cdev SMBus userspace interface</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#i2c-smbus-access"><span class="nav-number">1.2.8.3.8.1.</span> <span class="nav-text">i2c_smbus_access</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#i2c-smbus-write-quick"><span class="nav-number">1.2.8.3.8.2.</span> <span class="nav-text">i2c_smbus_write_quick</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#i2c-smbus-read-byte-1"><span class="nav-number">1.2.8.3.8.3.</span> <span class="nav-text">i2c_smbus_read_byte</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#i2c-smbus-write-byte-1"><span class="nav-number">1.2.8.3.8.4.</span> <span class="nav-text">i2c_smbus_write_byte</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#i2c-smbus-read-byte-data-1"><span class="nav-number">1.2.8.3.8.5.</span> <span class="nav-text">i2c_smbus_read_byte_data</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#i2c-smbus-write-byte-data-1"><span class="nav-number">1.2.8.3.8.6.</span> <span class="nav-text">i2c_smbus_write_byte_data</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#i2c-smbus-read-word-data-1"><span class="nav-number">1.2.8.3.8.7.</span> <span class="nav-text">i2c_smbus_read_word_data</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#i2c-smbus-write-word-data-1"><span class="nav-number">1.2.8.3.8.8.</span> <span class="nav-text">i2c_smbus_write_word_data</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#i2c-smbus-process-call"><span class="nav-number">1.2.8.3.8.9.</span> <span class="nav-text">i2c_smbus_process_call</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#i2c-smbus-read-block-data-1"><span class="nav-number">1.2.8.3.8.10.</span> <span class="nav-text">i2c_smbus_read_block_data</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#i2c-smbus-write-block-data-1"><span class="nav-number">1.2.8.3.8.11.</span> <span class="nav-text">i2c_smbus_write_block_data</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#i2c-smbus-write-i2c-block-data-1"><span class="nav-number">1.2.8.3.8.12.</span> <span class="nav-text">i2c_smbus_write_i2c_block_data</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jeffle</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.scheme !== 'Pisces' && (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always')) {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  
  

  


</body>
</html>
